// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ObjectRecords.proto

package or

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// version related operation type
type VersionInfo_OperationType int32

const (
	VersionInfo_NEW    VersionInfo_OperationType = 0
	VersionInfo_MARKER VersionInfo_OperationType = 1
	VersionInfo_REMOVE VersionInfo_OperationType = 2
	VersionInfo_UPDATE VersionInfo_OperationType = 3
)

var VersionInfo_OperationType_name = map[int32]string{
	0: "NEW",
	1: "MARKER",
	2: "REMOVE",
	3: "UPDATE",
}
var VersionInfo_OperationType_value = map[string]int32{
	"NEW":    0,
	"MARKER": 1,
	"REMOVE": 2,
	"UPDATE": 3,
}

func (x VersionInfo_OperationType) Enum() *VersionInfo_OperationType {
	p := new(VersionInfo_OperationType)
	*p = x
	return p
}
func (x VersionInfo_OperationType) String() string {
	return proto.EnumName(VersionInfo_OperationType_name, int32(x))
}
func (x *VersionInfo_OperationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VersionInfo_OperationType_value, data, "VersionInfo_OperationType")
	if err != nil {
		return err
	}
	*x = VersionInfo_OperationType(value)
	return nil
}
func (VersionInfo_OperationType) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{0, 0} }

//
// Versioning related info
type VersionInfo struct {
	Type *VersionInfo_OperationType `protobuf:"varint,1,req,name=type,enum=or.VersionInfo_OperationType" json:"type,omitempty"`
	// true if this is a null id version, only present if is NEW or MARKER type
	IsNullId *bool `protobuf:"varint,2,opt,name=isNullId" json:"isNullId,omitempty"`
	// the version removed by an update, only present if is REMOVE type
	RemovedVersion *uint64 `protobuf:"varint,3,opt,name=removedVersion" json:"removedVersion,omitempty"`
	// when the version removal happened, only present if is REMOVE type
	RemovedTime *uint64 `protobuf:"varint,4,opt,name=removedTime" json:"removedTime,omitempty"`
	// the version get updated, only present if is UPDATE type
	UpdatedVersion   *uint64 `protobuf:"varint,5,opt,name=updatedVersion" json:"updatedVersion,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *VersionInfo) Reset()                    { *m = VersionInfo{} }
func (m *VersionInfo) String() string            { return proto.CompactTextString(m) }
func (*VersionInfo) ProtoMessage()               {}
func (*VersionInfo) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *VersionInfo) GetType() VersionInfo_OperationType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return VersionInfo_NEW
}

func (m *VersionInfo) GetIsNullId() bool {
	if m != nil && m.IsNullId != nil {
		return *m.IsNullId
	}
	return false
}

func (m *VersionInfo) GetRemovedVersion() uint64 {
	if m != nil && m.RemovedVersion != nil {
		return *m.RemovedVersion
	}
	return 0
}

func (m *VersionInfo) GetRemovedTime() uint64 {
	if m != nil && m.RemovedTime != nil {
		return *m.RemovedTime
	}
	return 0
}

func (m *VersionInfo) GetUpdatedVersion() uint64 {
	if m != nil && m.UpdatedVersion != nil {
		return *m.UpdatedVersion
	}
	return 0
}

type SystemMetadata struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SystemMetadata) Reset()                    { *m = SystemMetadata{} }
func (m *SystemMetadata) String() string            { return proto.CompactTextString(m) }
func (*SystemMetadata) ProtoMessage()               {}
func (*SystemMetadata) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *SystemMetadata) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *SystemMetadata) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type HeadSystemMetadata struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	IsDeleted        *bool   `protobuf:"varint,3,opt,name=isDeleted" json:"isDeleted,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *HeadSystemMetadata) Reset()                    { *m = HeadSystemMetadata{} }
func (m *HeadSystemMetadata) String() string            { return proto.CompactTextString(m) }
func (*HeadSystemMetadata) ProtoMessage()               {}
func (*HeadSystemMetadata) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

func (m *HeadSystemMetadata) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *HeadSystemMetadata) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *HeadSystemMetadata) GetIsDeleted() bool {
	if m != nil && m.IsDeleted != nil {
		return *m.IsDeleted
	}
	return false
}

type UserMetadata struct {
	Key *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	// TODO: possibly add a type field to ensure only one of these is set
	IsDeleted        *bool   `protobuf:"varint,2,opt,name=isDeleted" json:"isDeleted,omitempty"`
	TextValue        *string `protobuf:"bytes,3,opt,name=textValue" json:"textValue,omitempty"`
	BinaryValue      []byte  `protobuf:"bytes,4,opt,name=binaryValue" json:"binaryValue,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UserMetadata) Reset()                    { *m = UserMetadata{} }
func (m *UserMetadata) String() string            { return proto.CompactTextString(m) }
func (*UserMetadata) ProtoMessage()               {}
func (*UserMetadata) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{3} }

func (m *UserMetadata) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *UserMetadata) GetIsDeleted() bool {
	if m != nil && m.IsDeleted != nil {
		return *m.IsDeleted
	}
	return false
}

func (m *UserMetadata) GetTextValue() string {
	if m != nil && m.TextValue != nil {
		return *m.TextValue
	}
	return ""
}

func (m *UserMetadata) GetBinaryValue() []byte {
	if m != nil {
		return m.BinaryValue
	}
	return nil
}

type DataRange struct {
	// The '-1' value of the objectOffset means the data offset in the
	// object is unknown. The process needs to construct the full mapping
	// by reading the latest index file and scanning the update files (the
	// latest index version ~ the latest update version).
	ObjectOffset *int64 `protobuf:"varint,1,req,name=objectOffset,def=-1" json:"objectOffset,omitempty"`
	// object data length
	// -1 value for objectLength means the data segment length is unknown.
	// The actual data segment length is determined by reading the size of the
	// file being pointed to and adjusting for the file offset.
	ObjectLength     *uint64 `protobuf:"varint,2,req,name=objectLength" json:"objectLength,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DataRange) Reset()                    { *m = DataRange{} }
func (m *DataRange) String() string            { return proto.CompactTextString(m) }
func (*DataRange) ProtoMessage()               {}
func (*DataRange) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{4} }

const Default_DataRange_ObjectOffset int64 = -1

func (m *DataRange) GetObjectOffset() int64 {
	if m != nil && m.ObjectOffset != nil {
		return *m.ObjectOffset
	}
	return Default_DataRange_ObjectOffset
}

func (m *DataRange) GetObjectLength() uint64 {
	if m != nil && m.ObjectLength != nil {
		return *m.ObjectLength
	}
	return 0
}

type DataIndex struct {
	// updated object segment
	DataRange *DataRange `protobuf:"bytes,1,req,name=dataRange" json:"dataRange,omitempty"`
	// location of the object segment
	// if segment location is null, the object data is stored in the same file along
	// with the the metadata record (UMR/IMR).
	// TODO: enforce these constraints in the code
	SegmentLocation *SegmentLocation `protobuf:"bytes,2,opt,name=segmentLocation" json:"segmentLocation,omitempty"`
	// the priority for this data
	SegmentPriority  *int64 `protobuf:"varint,3,req,name=segmentPriority,def=-1" json:"segmentPriority,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DataIndex) Reset()                    { *m = DataIndex{} }
func (m *DataIndex) String() string            { return proto.CompactTextString(m) }
func (*DataIndex) ProtoMessage()               {}
func (*DataIndex) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{5} }

const Default_DataIndex_SegmentPriority int64 = -1

func (m *DataIndex) GetDataRange() *DataRange {
	if m != nil {
		return m.DataRange
	}
	return nil
}

func (m *DataIndex) GetSegmentLocation() *SegmentLocation {
	if m != nil {
		return m.SegmentLocation
	}
	return nil
}

func (m *DataIndex) GetSegmentPriority() int64 {
	if m != nil && m.SegmentPriority != nil {
		return *m.SegmentPriority
	}
	return Default_DataIndex_SegmentPriority
}

//
// The metadata record in the index file, include all system
// metadata, user metadata and data indices.
// SS: Too bad GPB doesn't do message type inheritance, otherwise IMR could be a
// derivative of UMR
type IndexMetadataRecord struct {
	SysMd         []*SystemMetadata `protobuf:"bytes,1,rep,name=sysMd" json:"sysMd,omitempty"`
	HasMoreSysMd  *bool             `protobuf:"varint,2,opt,name=hasMoreSysMd,def=0" json:"hasMoreSysMd,omitempty"`
	UserMd        []*UserMetadata   `protobuf:"bytes,3,rep,name=userMd" json:"userMd,omitempty"`
	HasMoreUserMd *bool             `protobuf:"varint,4,opt,name=hasMoreUserMd,def=0" json:"hasMoreUserMd,omitempty"`
	// IndexMetadataRecord may contain at most one of the following:
	// * One data index and no SegmentLocation -- object data is stored inline in the
	//   index file
	// * A list of data indices, each with valid SegmentLocation -- each index
	//   points to a file that contains an object data segment
	// * BPlusTreeRecord -- pointer to the root of a BPlusTree structured data indices.
	//   Note that BPlusTree structured indices are not planned for the near term, and
	//   will be implemented in a later release.
	// If the object does not contain any data, the IndexMetadataRecord will not
	// contain any of the above.
	// TODO: if BPlusTree is not in the horizon for object index maintanance,
	// TODO: we can combine IMR and UMR
	DataIndices        []*DataIndex `protobuf:"bytes,5,rep,name=dataIndices" json:"dataIndices,omitempty"`
	HasMoreDataIndices *bool        `protobuf:"varint,6,opt,name=hasMoreDataIndices,def=0" json:"hasMoreDataIndices,omitempty"`
	// if any of the above booleans is true, then reposIMRLocation contains the list of
	// SegmentLocations of the record written to file
	ReposIMRLocations []*SegmentLocation `protobuf:"bytes,7,rep,name=reposIMRLocations" json:"reposIMRLocations,omitempty"`
	BPlusTreeRecord   *BPlusTreeRecord   `protobuf:"bytes,8,opt,name=bPlusTreeRecord" json:"bPlusTreeRecord,omitempty"`
	// Possibly updated head system metadata in the index file
	HeadSysMd        []*HeadSystemMetadata `protobuf:"bytes,9,rep,name=headSysMd" json:"headSysMd,omitempty"`
	HasMoreHeadSysMd *bool                 `protobuf:"varint,10,opt,name=hasMoreHeadSysMd,def=0" json:"hasMoreHeadSysMd,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *IndexMetadataRecord) Reset()                    { *m = IndexMetadataRecord{} }
func (m *IndexMetadataRecord) String() string            { return proto.CompactTextString(m) }
func (*IndexMetadataRecord) ProtoMessage()               {}
func (*IndexMetadataRecord) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{6} }

const Default_IndexMetadataRecord_HasMoreSysMd bool = false
const Default_IndexMetadataRecord_HasMoreUserMd bool = false
const Default_IndexMetadataRecord_HasMoreDataIndices bool = false
const Default_IndexMetadataRecord_HasMoreHeadSysMd bool = false

func (m *IndexMetadataRecord) GetSysMd() []*SystemMetadata {
	if m != nil {
		return m.SysMd
	}
	return nil
}

func (m *IndexMetadataRecord) GetHasMoreSysMd() bool {
	if m != nil && m.HasMoreSysMd != nil {
		return *m.HasMoreSysMd
	}
	return Default_IndexMetadataRecord_HasMoreSysMd
}

func (m *IndexMetadataRecord) GetUserMd() []*UserMetadata {
	if m != nil {
		return m.UserMd
	}
	return nil
}

func (m *IndexMetadataRecord) GetHasMoreUserMd() bool {
	if m != nil && m.HasMoreUserMd != nil {
		return *m.HasMoreUserMd
	}
	return Default_IndexMetadataRecord_HasMoreUserMd
}

func (m *IndexMetadataRecord) GetDataIndices() []*DataIndex {
	if m != nil {
		return m.DataIndices
	}
	return nil
}

func (m *IndexMetadataRecord) GetHasMoreDataIndices() bool {
	if m != nil && m.HasMoreDataIndices != nil {
		return *m.HasMoreDataIndices
	}
	return Default_IndexMetadataRecord_HasMoreDataIndices
}

func (m *IndexMetadataRecord) GetReposIMRLocations() []*SegmentLocation {
	if m != nil {
		return m.ReposIMRLocations
	}
	return nil
}

func (m *IndexMetadataRecord) GetBPlusTreeRecord() *BPlusTreeRecord {
	if m != nil {
		return m.BPlusTreeRecord
	}
	return nil
}

func (m *IndexMetadataRecord) GetHeadSysMd() []*HeadSystemMetadata {
	if m != nil {
		return m.HeadSysMd
	}
	return nil
}

func (m *IndexMetadataRecord) GetHasMoreHeadSysMd() bool {
	if m != nil && m.HasMoreHeadSysMd != nil {
		return *m.HasMoreHeadSysMd
	}
	return Default_IndexMetadataRecord_HasMoreHeadSysMd
}

type SystemMetadataSet struct {
	SysMd             []*SystemMetadata  `protobuf:"bytes,1,rep,name=sysMd" json:"sysMd,omitempty"`
	HasMoreMetadata   *bool              `protobuf:"varint,2,req,name=hasMoreMetadata,def=0" json:"hasMoreMetadata,omitempty"`
	RepoFileLocations []*SegmentLocation `protobuf:"bytes,3,rep,name=repoFileLocations" json:"repoFileLocations,omitempty"`
	XXX_unrecognized  []byte             `json:"-"`
}

func (m *SystemMetadataSet) Reset()                    { *m = SystemMetadataSet{} }
func (m *SystemMetadataSet) String() string            { return proto.CompactTextString(m) }
func (*SystemMetadataSet) ProtoMessage()               {}
func (*SystemMetadataSet) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{7} }

const Default_SystemMetadataSet_HasMoreMetadata bool = false

func (m *SystemMetadataSet) GetSysMd() []*SystemMetadata {
	if m != nil {
		return m.SysMd
	}
	return nil
}

func (m *SystemMetadataSet) GetHasMoreMetadata() bool {
	if m != nil && m.HasMoreMetadata != nil {
		return *m.HasMoreMetadata
	}
	return Default_SystemMetadataSet_HasMoreMetadata
}

func (m *SystemMetadataSet) GetRepoFileLocations() []*SegmentLocation {
	if m != nil {
		return m.RepoFileLocations
	}
	return nil
}

type UserMetadataSet struct {
	UserMd            []*UserMetadata    `protobuf:"bytes,1,rep,name=userMd" json:"userMd,omitempty"`
	HasMoreMetadata   *bool              `protobuf:"varint,2,req,name=hasMoreMetadata,def=0" json:"hasMoreMetadata,omitempty"`
	RepoFileLocations []*SegmentLocation `protobuf:"bytes,3,rep,name=repoFileLocations" json:"repoFileLocations,omitempty"`
	XXX_unrecognized  []byte             `json:"-"`
}

func (m *UserMetadataSet) Reset()                    { *m = UserMetadataSet{} }
func (m *UserMetadataSet) String() string            { return proto.CompactTextString(m) }
func (*UserMetadataSet) ProtoMessage()               {}
func (*UserMetadataSet) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{8} }

const Default_UserMetadataSet_HasMoreMetadata bool = false

func (m *UserMetadataSet) GetUserMd() []*UserMetadata {
	if m != nil {
		return m.UserMd
	}
	return nil
}

func (m *UserMetadataSet) GetHasMoreMetadata() bool {
	if m != nil && m.HasMoreMetadata != nil {
		return *m.HasMoreMetadata
	}
	return Default_UserMetadataSet_HasMoreMetadata
}

func (m *UserMetadataSet) GetRepoFileLocations() []*SegmentLocation {
	if m != nil {
		return m.RepoFileLocations
	}
	return nil
}

type HeadMetadataSet struct {
	HeadMd            []*HeadSystemMetadata `protobuf:"bytes,1,rep,name=headMd" json:"headMd,omitempty"`
	HasMoreMetadata   *bool                 `protobuf:"varint,2,req,name=hasMoreMetadata,def=0" json:"hasMoreMetadata,omitempty"`
	RepoFileLocations []*SegmentLocation    `protobuf:"bytes,3,rep,name=repoFileLocations" json:"repoFileLocations,omitempty"`
	XXX_unrecognized  []byte                `json:"-"`
}

func (m *HeadMetadataSet) Reset()                    { *m = HeadMetadataSet{} }
func (m *HeadMetadataSet) String() string            { return proto.CompactTextString(m) }
func (*HeadMetadataSet) ProtoMessage()               {}
func (*HeadMetadataSet) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{9} }

const Default_HeadMetadataSet_HasMoreMetadata bool = false

func (m *HeadMetadataSet) GetHeadMd() []*HeadSystemMetadata {
	if m != nil {
		return m.HeadMd
	}
	return nil
}

func (m *HeadMetadataSet) GetHasMoreMetadata() bool {
	if m != nil && m.HasMoreMetadata != nil {
		return *m.HasMoreMetadata
	}
	return Default_HeadMetadataSet_HasMoreMetadata
}

func (m *HeadMetadataSet) GetRepoFileLocations() []*SegmentLocation {
	if m != nil {
		return m.RepoFileLocations
	}
	return nil
}

// This is used to serialize all the overflow metadata into repo file.
type MetadataSet struct {
	HeadMd           []*HeadSystemMetadata `protobuf:"bytes,1,rep,name=headMd" json:"headMd,omitempty"`
	SysMd            []*SystemMetadata     `protobuf:"bytes,2,rep,name=sysMd" json:"sysMd,omitempty"`
	UserMd           []*UserMetadata       `protobuf:"bytes,3,rep,name=userMd" json:"userMd,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *MetadataSet) Reset()                    { *m = MetadataSet{} }
func (m *MetadataSet) String() string            { return proto.CompactTextString(m) }
func (*MetadataSet) ProtoMessage()               {}
func (*MetadataSet) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{10} }

func (m *MetadataSet) GetHeadMd() []*HeadSystemMetadata {
	if m != nil {
		return m.HeadMd
	}
	return nil
}

func (m *MetadataSet) GetSysMd() []*SystemMetadata {
	if m != nil {
		return m.SysMd
	}
	return nil
}

func (m *MetadataSet) GetUserMd() []*UserMetadata {
	if m != nil {
		return m.UserMd
	}
	return nil
}

// This is used to record the process.
// We need to execute the following in sequence:
// 1. update metadata and index range entries.
// 2. update compaction marker.
// 3. insert jobs to delete deprecated entries.
// Use sfixed64 to make overflow calculation simpler.
type CompactionMarker struct {
	LastIndexedSequence *int64 `protobuf:"fixed64,1,req,name=lastIndexedSequence" json:"lastIndexedSequence,omitempty"`
	// Sorted version history, from the latest to the oldest
	// We keep the version history here so that when the last version
	// of the object is removed, we know which one is the (new) current version.
	VersionHistoryDesc []int64 `protobuf:"fixed64,2,rep,name=versionHistoryDesc" json:"versionHistoryDesc,omitempty"`
	// nullVersionStartSequence is used to track the start sequence number of the
	// latest null sequence.
	// If there is a null version before version 1 and then we suspended versioning and
	// create a new null version, we need to update this field so that the next read
	// will not load indexes for the old null version.
	NullVersionStartSequence *int64 `protobuf:"fixed64,3,opt,name=nullVersionStartSequence" json:"nullVersionStartSequence,omitempty"`
	// In case there are lots of versions, this entry can overflow to repo chunks.
	RepoFileLocations []*SegmentLocation `protobuf:"bytes,4,rep,name=repoFileLocations" json:"repoFileLocations,omitempty"`
	XXX_unrecognized  []byte             `json:"-"`
}

func (m *CompactionMarker) Reset()                    { *m = CompactionMarker{} }
func (m *CompactionMarker) String() string            { return proto.CompactTextString(m) }
func (*CompactionMarker) ProtoMessage()               {}
func (*CompactionMarker) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{11} }

func (m *CompactionMarker) GetLastIndexedSequence() int64 {
	if m != nil && m.LastIndexedSequence != nil {
		return *m.LastIndexedSequence
	}
	return 0
}

func (m *CompactionMarker) GetVersionHistoryDesc() []int64 {
	if m != nil {
		return m.VersionHistoryDesc
	}
	return nil
}

func (m *CompactionMarker) GetNullVersionStartSequence() int64 {
	if m != nil && m.NullVersionStartSequence != nil {
		return *m.NullVersionStartSequence
	}
	return 0
}

func (m *CompactionMarker) GetRepoFileLocations() []*SegmentLocation {
	if m != nil {
		return m.RepoFileLocations
	}
	return nil
}

type VersionHistory struct {
	Versions         []int64 `protobuf:"fixed64,1,rep,name=versions" json:"versions,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *VersionHistory) Reset()                    { *m = VersionHistory{} }
func (m *VersionHistory) String() string            { return proto.CompactTextString(m) }
func (*VersionHistory) ProtoMessage()               {}
func (*VersionHistory) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{12} }

func (m *VersionHistory) GetVersions() []int64 {
	if m != nil {
		return m.Versions
	}
	return nil
}

//
// The metadata record in the update file.
//
// The update file format:
//   The following metadata record size, 4 bytes (int).
//   Metadata record.
//   Data.
type UpdateMetadataRecord struct {
	// Possibly updated system metadata in the update file
	SysMd        []*SystemMetadata `protobuf:"bytes,1,rep,name=sysMd" json:"sysMd,omitempty"`
	HasMoreSysMd *bool             `protobuf:"varint,2,opt,name=hasMoreSysMd,def=0" json:"hasMoreSysMd,omitempty"`
	// Possibly updated user metadata in the update file
	UserMd        []*UserMetadata `protobuf:"bytes,3,rep,name=userMd" json:"userMd,omitempty"`
	HasMoreUserMd *bool           `protobuf:"varint,4,opt,name=hasMoreUserMd,def=0" json:"hasMoreUserMd,omitempty"`
	// List of indices pointing to data segments that correspond to this update
	DataIndices        []*DataIndex `protobuf:"bytes,5,rep,name=dataIndices" json:"dataIndices,omitempty"`
	HasMoreDataIndices *bool        `protobuf:"varint,6,opt,name=hasMoreDataIndices,def=0" json:"hasMoreDataIndices,omitempty"`
	// if any of the above booleans is true, or if the request contains inline data
	// that is written to repository file, then reposUMRLocations contains the list of
	// SegmentLocations of the record written to file
	ReposUMRLocations []*SegmentLocation `protobuf:"bytes,7,rep,name=reposUMRLocations" json:"reposUMRLocations,omitempty"`
	// Possibly updated head system metadata in the update file
	HeadSysMd        []*HeadSystemMetadata `protobuf:"bytes,8,rep,name=headSysMd" json:"headSysMd,omitempty"`
	HasMoreHeadSysMd *bool                 `protobuf:"varint,9,opt,name=hasMoreHeadSysMd,def=0" json:"hasMoreHeadSysMd,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *UpdateMetadataRecord) Reset()                    { *m = UpdateMetadataRecord{} }
func (m *UpdateMetadataRecord) String() string            { return proto.CompactTextString(m) }
func (*UpdateMetadataRecord) ProtoMessage()               {}
func (*UpdateMetadataRecord) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{13} }

const Default_UpdateMetadataRecord_HasMoreSysMd bool = false
const Default_UpdateMetadataRecord_HasMoreUserMd bool = false
const Default_UpdateMetadataRecord_HasMoreDataIndices bool = false
const Default_UpdateMetadataRecord_HasMoreHeadSysMd bool = false

func (m *UpdateMetadataRecord) GetSysMd() []*SystemMetadata {
	if m != nil {
		return m.SysMd
	}
	return nil
}

func (m *UpdateMetadataRecord) GetHasMoreSysMd() bool {
	if m != nil && m.HasMoreSysMd != nil {
		return *m.HasMoreSysMd
	}
	return Default_UpdateMetadataRecord_HasMoreSysMd
}

func (m *UpdateMetadataRecord) GetUserMd() []*UserMetadata {
	if m != nil {
		return m.UserMd
	}
	return nil
}

func (m *UpdateMetadataRecord) GetHasMoreUserMd() bool {
	if m != nil && m.HasMoreUserMd != nil {
		return *m.HasMoreUserMd
	}
	return Default_UpdateMetadataRecord_HasMoreUserMd
}

func (m *UpdateMetadataRecord) GetDataIndices() []*DataIndex {
	if m != nil {
		return m.DataIndices
	}
	return nil
}

func (m *UpdateMetadataRecord) GetHasMoreDataIndices() bool {
	if m != nil && m.HasMoreDataIndices != nil {
		return *m.HasMoreDataIndices
	}
	return Default_UpdateMetadataRecord_HasMoreDataIndices
}

func (m *UpdateMetadataRecord) GetReposUMRLocations() []*SegmentLocation {
	if m != nil {
		return m.ReposUMRLocations
	}
	return nil
}

func (m *UpdateMetadataRecord) GetHeadSysMd() []*HeadSystemMetadata {
	if m != nil {
		return m.HeadSysMd
	}
	return nil
}

func (m *UpdateMetadataRecord) GetHasMoreHeadSysMd() bool {
	if m != nil && m.HasMoreHeadSysMd != nil {
		return *m.HasMoreHeadSysMd
	}
	return Default_UpdateMetadataRecord_HasMoreHeadSysMd
}

type CrossReferenceRecord struct {
	VersionId        *string `protobuf:"bytes,1,req,name=versionId" json:"versionId,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CrossReferenceRecord) Reset()                    { *m = CrossReferenceRecord{} }
func (m *CrossReferenceRecord) String() string            { return proto.CompactTextString(m) }
func (*CrossReferenceRecord) ProtoMessage()               {}
func (*CrossReferenceRecord) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{14} }

func (m *CrossReferenceRecord) GetVersionId() string {
	if m != nil && m.VersionId != nil {
		return *m.VersionId
	}
	return ""
}

func init() {
	proto.RegisterType((*VersionInfo)(nil), "or.VersionInfo")
	proto.RegisterType((*SystemMetadata)(nil), "or.SystemMetadata")
	proto.RegisterType((*HeadSystemMetadata)(nil), "or.HeadSystemMetadata")
	proto.RegisterType((*UserMetadata)(nil), "or.UserMetadata")
	proto.RegisterType((*DataRange)(nil), "or.DataRange")
	proto.RegisterType((*DataIndex)(nil), "or.DataIndex")
	proto.RegisterType((*IndexMetadataRecord)(nil), "or.IndexMetadataRecord")
	proto.RegisterType((*SystemMetadataSet)(nil), "or.SystemMetadataSet")
	proto.RegisterType((*UserMetadataSet)(nil), "or.UserMetadataSet")
	proto.RegisterType((*HeadMetadataSet)(nil), "or.HeadMetadataSet")
	proto.RegisterType((*MetadataSet)(nil), "or.MetadataSet")
	proto.RegisterType((*CompactionMarker)(nil), "or.CompactionMarker")
	proto.RegisterType((*VersionHistory)(nil), "or.VersionHistory")
	proto.RegisterType((*UpdateMetadataRecord)(nil), "or.UpdateMetadataRecord")
	proto.RegisterType((*CrossReferenceRecord)(nil), "or.CrossReferenceRecord")
	proto.RegisterEnum("or.VersionInfo_OperationType", VersionInfo_OperationType_name, VersionInfo_OperationType_value)
}

func init() { proto.RegisterFile("ObjectRecords.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 917 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x56, 0xc1, 0x6e, 0xdb, 0x46,
	0x10, 0x2d, 0x49, 0xd9, 0x11, 0x47, 0xb6, 0xc5, 0xac, 0x8d, 0x80, 0x70, 0x53, 0x40, 0xe0, 0xa1,
	0x50, 0x91, 0x54, 0xa9, 0x8d, 0x14, 0x28, 0x8c, 0xf6, 0x60, 0x47, 0x2a, 0x2c, 0x34, 0x8a, 0x8d,
	0x95, 0xe5, 0x00, 0xbd, 0xad, 0xc5, 0x91, 0xcd, 0x86, 0xe2, 0xaa, 0xbb, 0x2b, 0x23, 0xba, 0xf4,
	0x0b, 0x7a, 0x29, 0xd0, 0x5f, 0xe8, 0xb9, 0xe8, 0xa1, 0xbf, 0xd2, 0x1f, 0xe9, 0x0f, 0x14, 0xbb,
	0xa4, 0x28, 0x52, 0x56, 0xe2, 0xb8, 0x39, 0xe4, 0x92, 0x1b, 0x39, 0xf3, 0xe6, 0xcd, 0xec, 0xbc,
	0xd9, 0x21, 0x61, 0xfb, 0xe4, 0xe2, 0x27, 0x1c, 0x2a, 0x8a, 0x43, 0x2e, 0x42, 0xd9, 0x9a, 0x08,
	0xae, 0x38, 0xb1, 0xb9, 0xd8, 0xfd, 0xb4, 0x8f, 0x97, 0x63, 0x4c, 0xd4, 0x73, 0x3e, 0x64, 0x2a,
	0xe2, 0x49, 0x8a, 0x48, 0x01, 0xbb, 0x0f, 0x8e, 0x4e, 0xe3, 0xa9, 0x3c, 0x13, 0x88, 0xa5, 0xc0,
	0xe0, 0x57, 0x1b, 0x6a, 0xe7, 0x28, 0x64, 0xc4, 0x93, 0x6e, 0x32, 0xe2, 0x64, 0x0f, 0x2a, 0x6a,
	0x36, 0x41, 0xdf, 0x6a, 0xd8, 0xcd, 0xad, 0xfd, 0xcf, 0x5a, 0x5c, 0xb4, 0x0a, 0xee, 0xd6, 0xc9,
	0x04, 0x85, 0x21, 0x3f, 0x9b, 0x4d, 0x90, 0x1a, 0x28, 0xd9, 0x85, 0x6a, 0x24, 0x5f, 0x4c, 0xe3,
	0xb8, 0x1b, 0xfa, 0x76, 0xc3, 0x6a, 0x56, 0x69, 0xfe, 0x4e, 0x3e, 0x87, 0x2d, 0x81, 0x63, 0x7e,
	0x8d, 0x61, 0xc6, 0xe2, 0x3b, 0x0d, 0xab, 0x59, 0xa1, 0x4b, 0x56, 0xd2, 0x80, 0x5a, 0x66, 0x39,
	0x8b, 0xc6, 0xe8, 0x57, 0x0c, 0xa8, 0x68, 0xd2, 0x4c, 0xd3, 0x49, 0xc8, 0xd4, 0x82, 0x69, 0x2d,
	0x65, 0x2a, 0x5b, 0x83, 0x6f, 0x61, 0xb3, 0x54, 0x24, 0xb9, 0x07, 0xce, 0x8b, 0xce, 0x4b, 0xef,
	0x13, 0x02, 0xb0, 0xde, 0x3b, 0xa4, 0x3f, 0x74, 0xa8, 0x67, 0xe9, 0x67, 0xda, 0xe9, 0x9d, 0x9c,
	0x77, 0x3c, 0x5b, 0x3f, 0x0f, 0x4e, 0xdb, 0x87, 0x67, 0x1d, 0xcf, 0x09, 0xbe, 0x81, 0xad, 0xfe,
	0x4c, 0x2a, 0x1c, 0xf7, 0x50, 0xb1, 0x90, 0x29, 0x46, 0x3c, 0x70, 0x5e, 0xe1, 0xcc, 0xf4, 0xc3,
	0xa5, 0xfa, 0x91, 0xec, 0xc0, 0xda, 0x35, 0x8b, 0xa7, 0x68, 0x0e, 0xeb, 0xd2, 0xf4, 0x25, 0xf8,
	0x11, 0xc8, 0x31, 0xb2, 0xf0, 0xff, 0x45, 0x93, 0x87, 0xe0, 0x46, 0xb2, 0x8d, 0x31, 0x2a, 0x0c,
	0x4d, 0x8b, 0xaa, 0x74, 0x61, 0x08, 0x7e, 0x81, 0x8d, 0x81, 0x44, 0xf1, 0x16, 0xd6, 0x52, 0xbc,
	0xbd, 0x14, 0xaf, 0xbd, 0x0a, 0x5f, 0xab, 0x73, 0x93, 0xd7, 0x31, 0x79, 0x17, 0x06, 0xdd, 0xfb,
	0x8b, 0x28, 0x61, 0x62, 0x96, 0xfa, 0x75, 0xef, 0x37, 0x68, 0xd1, 0x14, 0xbc, 0x04, 0xb7, 0xcd,
	0x14, 0xa3, 0x2c, 0xb9, 0xd4, 0x42, 0x6c, 0x70, 0x33, 0x81, 0x27, 0xa3, 0x91, 0x44, 0x65, 0xaa,
	0x70, 0x0e, 0xec, 0x2f, 0xf7, 0x68, 0xc9, 0x4e, 0x82, 0x39, 0xee, 0x39, 0x26, 0x97, 0xea, 0xca,
	0xb7, 0x1b, 0x76, 0xb3, 0x42, 0x4b, 0xb6, 0xe0, 0x0f, 0x2b, 0x65, 0xee, 0x26, 0x21, 0xbe, 0x26,
	0x8f, 0xc0, 0x0d, 0xe7, 0x69, 0x0c, 0x6d, 0x6d, 0x7f, 0x53, 0x0f, 0x60, 0x9e, 0x9b, 0x2e, 0xfc,
	0xe4, 0x3b, 0xa8, 0xcb, 0xf2, 0xbc, 0x9b, 0x73, 0xd7, 0xf6, 0xb7, 0x75, 0xc8, 0xf2, 0x55, 0x58,
	0xc6, 0x92, 0xc7, 0x79, 0xf8, 0xa9, 0x88, 0xb8, 0x88, 0xd4, 0xcc, 0x77, 0xf2, 0x83, 0x2c, 0xbb,
	0x82, 0xdf, 0x2b, 0xb0, 0x6d, 0x6a, 0x9c, 0x4b, 0x90, 0x5e, 0x22, 0xd2, 0x84, 0x35, 0x39, 0x93,
	0xbd, 0xd0, 0xb7, 0x1a, 0x4e, 0xb3, 0xb6, 0x4f, 0x4c, 0xea, 0xd2, 0x04, 0xd0, 0x14, 0x40, 0xbe,
	0x80, 0x8d, 0x2b, 0x26, 0x7b, 0x5c, 0x60, 0xdf, 0x04, 0x18, 0x8d, 0x0e, 0xd6, 0x46, 0x2c, 0x96,
	0x48, 0x4b, 0x2e, 0xd2, 0x84, 0xf5, 0xa9, 0x56, 0x5b, 0x0f, 0x82, 0x66, 0xf5, 0x34, 0x6b, 0x51,
	0x7f, 0x9a, 0xf9, 0xc9, 0x23, 0xd8, 0xcc, 0x22, 0x07, 0x69, 0x40, 0xa5, 0xc8, 0x5a, 0xf6, 0x91,
	0x27, 0x50, 0x0b, 0xd3, 0x56, 0x47, 0x43, 0x94, 0xfe, 0x9a, 0xe1, 0xce, 0xfb, 0x6b, 0x4e, 0x47,
	0x8b, 0x08, 0xf2, 0x35, 0x90, 0x8c, 0xa1, 0x5d, 0x88, 0x5b, 0x2f, 0xa6, 0x58, 0x01, 0x20, 0x87,
	0x70, 0x5f, 0xe0, 0x84, 0xcb, 0x6e, 0x8f, 0xce, 0xbb, 0x2d, 0xfd, 0x7b, 0x26, 0xdb, 0x4a, 0x69,
	0x6e, 0xa2, 0xb5, 0xb6, 0x17, 0xe5, 0x75, 0xe5, 0x57, 0x17, 0xda, 0x2e, 0x6d, 0x32, 0xba, 0x8c,
	0x25, 0x4f, 0xc1, 0xbd, 0x4a, 0xaf, 0x62, 0x2f, 0xf4, 0x5d, 0x93, 0xf9, 0x81, 0x0e, 0xbc, 0x79,
	0x3f, 0xe9, 0x02, 0x48, 0xf6, 0xc0, 0xcb, 0x4e, 0x73, 0x9c, 0x07, 0x43, 0xf1, 0xb0, 0x37, 0xdc,
	0xc1, 0x5f, 0x16, 0xdc, 0x2f, 0x13, 0xf6, 0x51, 0xdd, 0x61, 0x28, 0x9e, 0x40, 0x3d, 0xe3, 0x9c,
	0x7b, 0xcc, 0x2d, 0xc9, 0x33, 0x2e, 0x7b, 0xe7, 0xbd, 0xfd, 0x3e, 0x8a, 0x71, 0xd1, 0x5b, 0xe7,
	0x96, 0xde, 0x96, 0xd0, 0xc1, 0x9f, 0x16, 0xd4, 0x8b, 0xc3, 0x94, 0x56, 0x3c, 0x9f, 0x38, 0xeb,
	0x96, 0x89, 0xfb, 0x10, 0x15, 0xff, 0x6d, 0x41, 0x5d, 0xf7, 0xbc, 0x58, 0x71, 0x0b, 0xd6, 0xb5,
	0x72, 0x79, 0xc5, 0x6f, 0xd2, 0x37, 0x43, 0x7d, 0x90, 0xba, 0x7f, 0xb3, 0xa0, 0xf6, 0x3e, 0x35,
	0xe7, 0x73, 0x64, 0xdf, 0x36, 0x47, 0xef, 0xbc, 0x31, 0x82, 0x7f, 0x2d, 0xf0, 0x9e, 0xf1, 0xf1,
	0x84, 0x0d, 0x75, 0x8d, 0x3d, 0x26, 0x5e, 0xa1, 0x20, 0x5f, 0xc1, 0x76, 0xcc, 0xa4, 0x32, 0x2b,
	0x00, 0xc3, 0x3e, 0xfe, 0x3c, 0xc5, 0x64, 0x98, 0x6e, 0x60, 0x8f, 0xae, 0x72, 0x91, 0x16, 0x90,
	0xeb, 0xf4, 0x7b, 0x7b, 0x1c, 0x49, 0xc5, 0xc5, 0xac, 0x8d, 0x72, 0x68, 0xea, 0xf4, 0xe8, 0x0a,
	0x0f, 0x39, 0x00, 0x3f, 0x99, 0xc6, 0x71, 0xf6, 0x8d, 0xee, 0x2b, 0x26, 0x54, 0x9e, 0x46, 0x7f,
	0x8f, 0x3c, 0xfa, 0x46, 0xff, 0x6a, 0x25, 0x2a, 0x77, 0x52, 0xe2, 0x31, 0x6c, 0x9d, 0x97, 0x8a,
	0xd2, 0xff, 0x2c, 0x59, 0x99, 0xd2, 0xa8, 0xe1, 0xd1, 0xfc, 0x3d, 0xf8, 0xc7, 0x81, 0x9d, 0x81,
	0xf9, 0xa9, 0xf8, 0xb8, 0xed, 0xdf, 0x79, 0xdb, 0x0f, 0xee, 0xb4, 0xed, 0x8b, 0xe8, 0xf2, 0xba,
	0xae, 0xbe, 0xcf, 0xba, 0x76, 0xdf, 0xbe, 0xae, 0x9f, 0xc2, 0xce, 0x33, 0xc1, 0xa5, 0xa4, 0x38,
	0x42, 0xa1, 0x67, 0x2b, 0xd3, 0xf5, 0x21, 0xb8, 0x99, 0xf8, 0xdd, 0x30, 0xfb, 0xa9, 0x5a, 0x18,
	0x8e, 0xea, 0x47, 0x9b, 0xa5, 0x3f, 0xee, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xe2, 0xb5, 0xf6,
	0xe2, 0x81, 0x0b, 0x00, 0x00,
}
