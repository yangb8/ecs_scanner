// Code generated by protoc-gen-go. DO NOT EDIT.
// source: SegmentLocationRecord.proto

package or

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Snappy compression offers faster compression/decompression
// while the Java zip compression offers better compression ratios.
type CompressInfo_CompressAlgo int32

const (
	CompressInfo_SNAPPY CompressInfo_CompressAlgo = 0
)

var CompressInfo_CompressAlgo_name = map[int32]string{
	0: "SNAPPY",
}
var CompressInfo_CompressAlgo_value = map[string]int32{
	"SNAPPY": 0,
}

func (x CompressInfo_CompressAlgo) Enum() *CompressInfo_CompressAlgo {
	p := new(CompressInfo_CompressAlgo)
	*p = x
	return p
}
func (x CompressInfo_CompressAlgo) String() string {
	return proto.EnumName(CompressInfo_CompressAlgo_name, int32(x))
}
func (x *CompressInfo_CompressAlgo) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CompressInfo_CompressAlgo_value, data, "CompressInfo_CompressAlgo")
	if err != nil {
		return err
	}
	*x = CompressInfo_CompressAlgo(value)
	return nil
}
func (CompressInfo_CompressAlgo) EnumDescriptor() ([]byte, []int) { return fileDescriptor6, []int{0, 0} }

type CompressInfo struct {
	Algo             *CompressInfo_CompressAlgo `protobuf:"varint,1,req,name=algo,enum=or.CompressInfo_CompressAlgo,def=0" json:"algo,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *CompressInfo) Reset()                    { *m = CompressInfo{} }
func (m *CompressInfo) String() string            { return proto.CompactTextString(m) }
func (*CompressInfo) ProtoMessage()               {}
func (*CompressInfo) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0} }

const Default_CompressInfo_Algo CompressInfo_CompressAlgo = CompressInfo_SNAPPY

func (m *CompressInfo) GetAlgo() CompressInfo_CompressAlgo {
	if m != nil && m.Algo != nil {
		return *m.Algo
	}
	return Default_CompressInfo_Algo
}

type RangeInfo struct {
	// offset in logical range
	RelativeOffset *int64 `protobuf:"varint,1,opt,name=relativeOffset,def=0" json:"relativeOffset,omitempty"`
	// end offset in logical range
	RelativeEndOffset *int64 `protobuf:"varint,2,opt,name=relativeEndOffset,def=-1" json:"relativeEndOffset,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *RangeInfo) Reset()                    { *m = RangeInfo{} }
func (m *RangeInfo) String() string            { return proto.CompactTextString(m) }
func (*RangeInfo) ProtoMessage()               {}
func (*RangeInfo) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1} }

const Default_RangeInfo_RelativeOffset int64 = 0
const Default_RangeInfo_RelativeEndOffset int64 = -1

func (m *RangeInfo) GetRelativeOffset() int64 {
	if m != nil && m.RelativeOffset != nil {
		return *m.RelativeOffset
	}
	return Default_RangeInfo_RelativeOffset
}

func (m *RangeInfo) GetRelativeEndOffset() int64 {
	if m != nil && m.RelativeEndOffset != nil {
		return *m.RelativeEndOffset
	}
	return Default_RangeInfo_RelativeEndOffset
}

type SegmentLocation struct {
	// chunk on which the segment lays
	ChunkId *string `protobuf:"bytes,1,opt,name=chunkId" json:"chunkId,omitempty"`
	// the start offset of segment within the container
	Offset *int64 `protobuf:"varint,2,opt,name=offset,def=0" json:"offset,omitempty"`
	// the end offset (exclusive) of segment within the container
	EndOffset    *int64        `protobuf:"varint,3,opt,name=endOffset,def=-1" json:"endOffset,omitempty"`
	CompressInfo *CompressInfo `protobuf:"bytes,4,opt,name=compressInfo" json:"compressInfo,omitempty"`
	// data range info
	RangeInfo *RangeInfo `protobuf:"bytes,5,opt,name=rangeInfo" json:"rangeInfo,omitempty"`
	// if data validation needed
	IsValidationNeeded *bool `protobuf:"varint,6,opt,name=isValidationNeeded,def=1" json:"isValidationNeeded,omitempty"`
	// used for zkbtree
	ZkPath           *string `protobuf:"bytes,7,opt,name=zkPath" json:"zkPath,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SegmentLocation) Reset()                    { *m = SegmentLocation{} }
func (m *SegmentLocation) String() string            { return proto.CompactTextString(m) }
func (*SegmentLocation) ProtoMessage()               {}
func (*SegmentLocation) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{2} }

const Default_SegmentLocation_Offset int64 = 0
const Default_SegmentLocation_EndOffset int64 = -1
const Default_SegmentLocation_IsValidationNeeded bool = true

func (m *SegmentLocation) GetChunkId() string {
	if m != nil && m.ChunkId != nil {
		return *m.ChunkId
	}
	return ""
}

func (m *SegmentLocation) GetOffset() int64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return Default_SegmentLocation_Offset
}

func (m *SegmentLocation) GetEndOffset() int64 {
	if m != nil && m.EndOffset != nil {
		return *m.EndOffset
	}
	return Default_SegmentLocation_EndOffset
}

func (m *SegmentLocation) GetCompressInfo() *CompressInfo {
	if m != nil {
		return m.CompressInfo
	}
	return nil
}

func (m *SegmentLocation) GetRangeInfo() *RangeInfo {
	if m != nil {
		return m.RangeInfo
	}
	return nil
}

func (m *SegmentLocation) GetIsValidationNeeded() bool {
	if m != nil && m.IsValidationNeeded != nil {
		return *m.IsValidationNeeded
	}
	return Default_SegmentLocation_IsValidationNeeded
}

func (m *SegmentLocation) GetZkPath() string {
	if m != nil && m.ZkPath != nil {
		return *m.ZkPath
	}
	return ""
}

func init() {
	proto.RegisterType((*CompressInfo)(nil), "or.CompressInfo")
	proto.RegisterType((*RangeInfo)(nil), "or.RangeInfo")
	proto.RegisterType((*SegmentLocation)(nil), "or.SegmentLocation")
	proto.RegisterEnum("or.CompressInfo_CompressAlgo", CompressInfo_CompressAlgo_name, CompressInfo_CompressAlgo_value)
}

func init() { proto.RegisterFile("SegmentLocationRecord.proto", fileDescriptor6) }

var fileDescriptor6 = []byte{
	// 319 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0x41, 0x4f, 0xfa, 0x40,
	0x10, 0xc5, 0xff, 0x5b, 0xf8, 0x17, 0x3b, 0x22, 0xe2, 0x26, 0xea, 0xaa, 0x31, 0x69, 0x7a, 0xaa,
	0x31, 0x12, 0x24, 0x5c, 0xe4, 0x06, 0xc6, 0x03, 0x89, 0x41, 0xb2, 0x24, 0x26, 0x1e, 0x9b, 0x76,
	0x28, 0x0d, 0xa5, 0x43, 0xb6, 0x8b, 0x07, 0xbf, 0x89, 0xdf, 0xd6, 0xb0, 0x29, 0x05, 0x91, 0xe3,
	0xcc, 0x6f, 0xde, 0xbe, 0xbc, 0x97, 0x85, 0x9b, 0x09, 0xc6, 0x0b, 0xcc, 0xf4, 0x2b, 0x85, 0x81,
	0x4e, 0x28, 0x93, 0x18, 0x92, 0x8a, 0x5a, 0x4b, 0x45, 0x9a, 0xb8, 0x45, 0xca, 0x43, 0xa8, 0x3f,
	0xd3, 0x62, 0xa9, 0x30, 0xcf, 0x87, 0xd9, 0x94, 0xf8, 0x13, 0x54, 0x83, 0x34, 0x26, 0xc1, 0x5c,
	0xcb, 0x6f, 0x74, 0x6e, 0x5b, 0xa4, 0x5a, 0xbb, 0xbc, 0x1c, 0xfa, 0x69, 0x4c, 0x3d, 0x7b, 0x32,
	0xea, 0x8f, 0xc7, 0x1f, 0xd2, 0x48, 0xbc, 0xeb, 0xed, 0x53, 0x6b, 0xca, 0x01, 0x0a, 0xde, 0xfc,
	0xe7, 0xcd, 0xc0, 0x91, 0x41, 0x16, 0xa3, 0xf1, 0xb8, 0x83, 0x86, 0xc2, 0x34, 0xd0, 0xc9, 0x27,
	0xbe, 0x4d, 0xa7, 0x39, 0x6a, 0xc1, 0x5c, 0xe6, 0x57, 0x7a, 0xac, 0x2d, 0xf7, 0x00, 0x6f, 0xc3,
	0xd9, 0x66, 0xf3, 0x92, 0x45, 0xc5, 0xb5, 0x65, 0xae, 0xad, 0x87, 0x47, 0xf9, 0x17, 0x7a, 0xdf,
	0x16, 0x9c, 0xee, 0x85, 0xe6, 0x02, 0x6a, 0xe1, 0x6c, 0x95, 0xcd, 0x87, 0x91, 0x71, 0x72, 0xe4,
	0x66, 0xe4, 0x57, 0x60, 0xd3, 0xee, 0xa3, 0xac, 0x2d, 0x8b, 0x05, 0x77, 0xc1, 0xc1, 0xd2, 0xb2,
	0x52, 0x5a, 0x6e, 0x97, 0xbc, 0x0b, 0xf5, 0x70, 0xa7, 0x1b, 0x51, 0x75, 0x99, 0x7f, 0xdc, 0x69,
	0xee, 0x77, 0x26, 0x7f, 0x5d, 0xf1, 0x7b, 0x70, 0xd4, 0xa6, 0x0a, 0xf1, 0xdf, 0x48, 0x4e, 0xd6,
	0x92, 0xb2, 0x1f, 0xb9, 0xe5, 0xbc, 0x0b, 0x3c, 0xc9, 0xdf, 0x83, 0x34, 0x89, 0x4c, 0x92, 0x11,
	0x62, 0x84, 0x91, 0xb0, 0x5d, 0xe6, 0x1f, 0xf5, 0xaa, 0x5a, 0xad, 0x50, 0x1e, 0xe0, 0xfc, 0x02,
	0xec, 0xaf, 0xf9, 0x38, 0xd0, 0x33, 0x51, 0x33, 0x71, 0x8b, 0x69, 0x70, 0x39, 0x38, 0x3f, 0xf8,
	0x1f, 0x7e, 0x02, 0x00, 0x00, 0xff, 0xff, 0xda, 0x02, 0x62, 0x20, 0x27, 0x02, 0x00, 0x00,
}
