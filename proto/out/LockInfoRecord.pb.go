// Code generated by protoc-gen-go. DO NOT EDIT.
// source: LockInfoRecord.proto

package or

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type LockType int32

const (
	LockType_Shared    LockType = 1
	LockType_Exclusive LockType = 2
)

var LockType_name = map[int32]string{
	1: "Shared",
	2: "Exclusive",
}
var LockType_value = map[string]int32{
	"Shared":    1,
	"Exclusive": 2,
}

func (x LockType) Enum() *LockType {
	p := new(LockType)
	*p = x
	return p
}
func (x LockType) String() string {
	return proto.EnumName(LockType_name, int32(x))
}
func (x *LockType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LockType_value, data, "LockType")
	if err != nil {
		return err
	}
	*x = LockType(value)
	return nil
}
func (LockType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

type LockStatus int32

const (
	LockStatus_Granted LockStatus = 1
	LockStatus_Denied  LockStatus = 2
)

var LockStatus_name = map[int32]string{
	1: "Granted",
	2: "Denied",
}
var LockStatus_value = map[string]int32{
	"Granted": 1,
	"Denied":  2,
}

func (x LockStatus) Enum() *LockStatus {
	p := new(LockStatus)
	*p = x
	return p
}
func (x LockStatus) String() string {
	return proto.EnumName(LockStatus_name, int32(x))
}
func (x *LockStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LockStatus_value, data, "LockStatus")
	if err != nil {
		return err
	}
	*x = LockStatus(value)
	return nil
}
func (LockStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

type LockOperationType int32

const (
	LockOperationType_Lock   LockOperationType = 1
	LockOperationType_Unlock LockOperationType = 2
	LockOperationType_Cancel LockOperationType = 3
	LockOperationType_Test   LockOperationType = 4
)

var LockOperationType_name = map[int32]string{
	1: "Lock",
	2: "Unlock",
	3: "Cancel",
	4: "Test",
}
var LockOperationType_value = map[string]int32{
	"Lock":   1,
	"Unlock": 2,
	"Cancel": 3,
	"Test":   4,
}

func (x LockOperationType) Enum() *LockOperationType {
	p := new(LockOperationType)
	*p = x
	return p
}
func (x LockOperationType) String() string {
	return proto.EnumName(LockOperationType_name, int32(x))
}
func (x *LockOperationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LockOperationType_value, data, "LockOperationType")
	if err != nil {
		return err
	}
	*x = LockOperationType(value)
	return nil
}
func (LockOperationType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

type LockOwner struct {
	Owner            *string `protobuf:"bytes,1,req,name=owner" json:"owner,omitempty"`
	OwnerPrefix      *string `protobuf:"bytes,2,req,name=ownerPrefix" json:"ownerPrefix,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LockOwner) Reset()                    { *m = LockOwner{} }
func (m *LockOwner) String() string            { return proto.CompactTextString(m) }
func (*LockOwner) ProtoMessage()               {}
func (*LockOwner) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *LockOwner) GetOwner() string {
	if m != nil && m.Owner != nil {
		return *m.Owner
	}
	return ""
}

func (m *LockOwner) GetOwnerPrefix() string {
	if m != nil && m.OwnerPrefix != nil {
		return *m.OwnerPrefix
	}
	return ""
}

type ByteRange struct {
	Offset           *int64 `protobuf:"varint,1,req,name=offset" json:"offset,omitempty"`
	Length           *int64 `protobuf:"varint,2,req,name=length" json:"length,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ByteRange) Reset()                    { *m = ByteRange{} }
func (m *ByteRange) String() string            { return proto.CompactTextString(m) }
func (*ByteRange) ProtoMessage()               {}
func (*ByteRange) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *ByteRange) GetOffset() int64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *ByteRange) GetLength() int64 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

type LockInfo struct {
	// lock range info
	LockRange         *ByteRange         `protobuf:"bytes,1,req,name=lockRange" json:"lockRange,omitempty"`
	LockOperationType *LockOperationType `protobuf:"varint,2,req,name=lockOperationType,enum=or.LockOperationType" json:"lockOperationType,omitempty"`
	LockType          *LockType          `protobuf:"varint,3,req,name=lockType,enum=or.LockType" json:"lockType,omitempty"`
	Owner             *LockOwner         `protobuf:"bytes,4,req,name=owner" json:"owner,omitempty"`
	IsBlocking        *bool              `protobuf:"varint,5,opt,name=isBlocking" json:"isBlocking,omitempty"`
	LockSpace         *string            `protobuf:"bytes,6,opt,name=lockSpace" json:"lockSpace,omitempty"`
	Cookie            *string            `protobuf:"bytes,7,opt,name=cookie" json:"cookie,omitempty"`
	XXX_unrecognized  []byte             `json:"-"`
}

func (m *LockInfo) Reset()                    { *m = LockInfo{} }
func (m *LockInfo) String() string            { return proto.CompactTextString(m) }
func (*LockInfo) ProtoMessage()               {}
func (*LockInfo) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *LockInfo) GetLockRange() *ByteRange {
	if m != nil {
		return m.LockRange
	}
	return nil
}

func (m *LockInfo) GetLockOperationType() LockOperationType {
	if m != nil && m.LockOperationType != nil {
		return *m.LockOperationType
	}
	return LockOperationType_Lock
}

func (m *LockInfo) GetLockType() LockType {
	if m != nil && m.LockType != nil {
		return *m.LockType
	}
	return LockType_Shared
}

func (m *LockInfo) GetOwner() *LockOwner {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *LockInfo) GetIsBlocking() bool {
	if m != nil && m.IsBlocking != nil {
		return *m.IsBlocking
	}
	return false
}

func (m *LockInfo) GetLockSpace() string {
	if m != nil && m.LockSpace != nil {
		return *m.LockSpace
	}
	return ""
}

func (m *LockInfo) GetCookie() string {
	if m != nil && m.Cookie != nil {
		return *m.Cookie
	}
	return ""
}

func init() {
	proto.RegisterType((*LockOwner)(nil), "or.LockOwner")
	proto.RegisterType((*ByteRange)(nil), "or.ByteRange")
	proto.RegisterType((*LockInfo)(nil), "or.LockInfo")
	proto.RegisterEnum("or.LockType", LockType_name, LockType_value)
	proto.RegisterEnum("or.LockStatus", LockStatus_name, LockStatus_value)
	proto.RegisterEnum("or.LockOperationType", LockOperationType_name, LockOperationType_value)
}

func init() { proto.RegisterFile("LockInfoRecord.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 360 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x52, 0xcd, 0x6a, 0xea, 0x40,
	0x14, 0x26, 0x89, 0xc6, 0xe4, 0x78, 0x95, 0x38, 0x78, 0x4b, 0x16, 0xa5, 0x04, 0x8b, 0x10, 0x2c,
	0xb8, 0x70, 0xdb, 0x45, 0x21, 0xb6, 0x94, 0x82, 0x60, 0x19, 0xed, 0x03, 0x84, 0x78, 0xa2, 0xc1,
	0x30, 0x13, 0x26, 0x63, 0xab, 0x8f, 0xd3, 0x37, 0x2d, 0x33, 0x31, 0x6a, 0xeb, 0x6e, 0xbe, 0x5f,
	0x4e, 0x3e, 0x02, 0xfd, 0x19, 0x4f, 0xb6, 0x6f, 0x2c, 0xe5, 0x14, 0x13, 0x2e, 0x56, 0xe3, 0x42,
	0x70, 0xc9, 0x89, 0xc9, 0xc5, 0x60, 0x0a, 0xae, 0xd2, 0xe6, 0x5f, 0x0c, 0x05, 0xe9, 0x43, 0x93,
	0xab, 0x87, 0x6f, 0x04, 0x66, 0xe8, 0xd2, 0x0a, 0x90, 0x00, 0xda, 0xfa, 0xf1, 0x2e, 0x30, 0xcd,
	0xf6, 0xbe, 0xa9, 0xb5, 0x4b, 0x6a, 0xf0, 0x08, 0x6e, 0x74, 0x90, 0x48, 0x63, 0xb6, 0x46, 0x72,
	0x03, 0x36, 0x4f, 0xd3, 0x12, 0xa5, 0x6e, 0xb1, 0xe8, 0x11, 0x29, 0x3e, 0x47, 0xb6, 0x96, 0x1b,
	0xdd, 0x60, 0xd1, 0x23, 0x1a, 0x7c, 0x9b, 0xe0, 0xd4, 0xe7, 0x91, 0x07, 0x70, 0x73, 0x9e, 0x6c,
	0x75, 0x93, 0xce, 0xb7, 0x27, 0x9d, 0x31, 0x17, 0xe3, 0x53, 0x3d, 0x3d, 0xeb, 0x64, 0x0a, 0x3d,
	0x05, 0xe6, 0x05, 0x8a, 0x58, 0x66, 0x9c, 0x2d, 0x0f, 0x05, 0xea, 0xf2, 0xee, 0xe4, 0xbf, 0x0a,
	0xcd, 0xfe, 0x8a, 0xf4, 0xda, 0x4f, 0x42, 0x70, 0x14, 0xa9, 0xb3, 0x96, 0xce, 0xfe, 0xab, 0xb3,
	0x3a, 0x72, 0x52, 0xc9, 0x7d, 0xbd, 0x4e, 0xe3, 0x7c, 0xd7, 0x69, 0xbb, 0x7a, 0xac, 0x3b, 0x80,
	0xac, 0x8c, 0x54, 0x26, 0x63, 0x6b, 0xbf, 0x19, 0x18, 0xa1, 0x43, 0x2f, 0x18, 0x72, 0x5b, 0x7d,
	0xe0, 0xa2, 0x88, 0x13, 0xf4, 0xed, 0xc0, 0x08, 0x5d, 0x7a, 0x26, 0xd4, 0x46, 0x09, 0xe7, 0xdb,
	0x0c, 0xfd, 0x96, 0x96, 0x8e, 0x68, 0x34, 0xac, 0x26, 0xd2, 0x67, 0x00, 0xd8, 0x8b, 0x4d, 0x2c,
	0x70, 0xe5, 0x19, 0xa4, 0x03, 0xee, 0xcb, 0x3e, 0xc9, 0x77, 0x65, 0xf6, 0x89, 0x9e, 0x39, 0x1a,
	0x02, 0x28, 0xdb, 0x42, 0xc6, 0x72, 0x57, 0x92, 0x36, 0xb4, 0x5e, 0x45, 0xcc, 0xa4, 0x76, 0x02,
	0xd8, 0xcf, 0xc8, 0x32, 0x5c, 0x79, 0xe6, 0xe8, 0x09, 0x7a, 0x57, 0xd3, 0x10, 0x07, 0x1a, 0x8a,
	0xac, 0xac, 0x1f, 0x4c, 0xdd, 0xe4, 0x99, 0xea, 0x3d, 0x8d, 0x59, 0x82, 0xb9, 0x67, 0x29, 0xc7,
	0x12, 0x4b, 0xe9, 0x35, 0x22, 0x2f, 0xea, 0xfe, 0xfe, 0xa1, 0x7e, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x0d, 0xf7, 0xac, 0x5a, 0x61, 0x02, 0x00, 0x00,
}
