// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ObjectRecords.proto

package or

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// version related operation type
type VersionInfo_OperationType int32

const (
	VersionInfo_NEW    VersionInfo_OperationType = 0
	VersionInfo_MARKER VersionInfo_OperationType = 1
	VersionInfo_REMOVE VersionInfo_OperationType = 2
	VersionInfo_UPDATE VersionInfo_OperationType = 3
)

var VersionInfo_OperationType_name = map[int32]string{
	0: "NEW",
	1: "MARKER",
	2: "REMOVE",
	3: "UPDATE",
}
var VersionInfo_OperationType_value = map[string]int32{
	"NEW":    0,
	"MARKER": 1,
	"REMOVE": 2,
	"UPDATE": 3,
}

func (x VersionInfo_OperationType) Enum() *VersionInfo_OperationType {
	p := new(VersionInfo_OperationType)
	*p = x
	return p
}
func (x VersionInfo_OperationType) String() string {
	return proto.EnumName(VersionInfo_OperationType_name, int32(x))
}
func (x *VersionInfo_OperationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VersionInfo_OperationType_value, data, "VersionInfo_OperationType")
	if err != nil {
		return err
	}
	*x = VersionInfo_OperationType(value)
	return nil
}
func (VersionInfo_OperationType) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{0, 0} }

type CompactionMarker_MarkerVersionType int32

const (
	CompactionMarker_version22 CompactionMarker_MarkerVersionType = 0
)

var CompactionMarker_MarkerVersionType_name = map[int32]string{
	0: "version22",
}
var CompactionMarker_MarkerVersionType_value = map[string]int32{
	"version22": 0,
}

func (x CompactionMarker_MarkerVersionType) Enum() *CompactionMarker_MarkerVersionType {
	p := new(CompactionMarker_MarkerVersionType)
	*p = x
	return p
}
func (x CompactionMarker_MarkerVersionType) String() string {
	return proto.EnumName(CompactionMarker_MarkerVersionType_name, int32(x))
}
func (x *CompactionMarker_MarkerVersionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CompactionMarker_MarkerVersionType_value, data, "CompactionMarker_MarkerVersionType")
	if err != nil {
		return err
	}
	*x = CompactionMarker_MarkerVersionType(value)
	return nil
}
func (CompactionMarker_MarkerVersionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor3, []int{13, 0}
}

type RefTableRebuildTaskValue_Status int32

const (
	RefTableRebuildTaskValue_SCHEDULED RefTableRebuildTaskValue_Status = 1
	RefTableRebuildTaskValue_DONE      RefTableRebuildTaskValue_Status = 2
)

var RefTableRebuildTaskValue_Status_name = map[int32]string{
	1: "SCHEDULED",
	2: "DONE",
}
var RefTableRebuildTaskValue_Status_value = map[string]int32{
	"SCHEDULED": 1,
	"DONE":      2,
}

func (x RefTableRebuildTaskValue_Status) Enum() *RefTableRebuildTaskValue_Status {
	p := new(RefTableRebuildTaskValue_Status)
	*p = x
	return p
}
func (x RefTableRebuildTaskValue_Status) String() string {
	return proto.EnumName(RefTableRebuildTaskValue_Status_name, int32(x))
}
func (x *RefTableRebuildTaskValue_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RefTableRebuildTaskValue_Status_value, data, "RefTableRebuildTaskValue_Status")
	if err != nil {
		return err
	}
	*x = RefTableRebuildTaskValue_Status(value)
	return nil
}
func (RefTableRebuildTaskValue_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor3, []int{22, 0}
}

//
// Versioning related info
type VersionInfo struct {
	Type *VersionInfo_OperationType `protobuf:"varint,1,req,name=type,enum=or.VersionInfo_OperationType" json:"type,omitempty"`
	// true if this is a null id version, only present if is NEW or MARKER type
	IsNullId *bool `protobuf:"varint,2,opt,name=isNullId" json:"isNullId,omitempty"`
	// the version removed by an update, only present if is REMOVE type
	RemovedVersion *uint64 `protobuf:"varint,3,opt,name=removedVersion" json:"removedVersion,omitempty"`
	// when the version removal happened, only present if is REMOVE type
	RemovedTime *uint64 `protobuf:"varint,4,opt,name=removedTime" json:"removedTime,omitempty"`
	// the version get updated, only present if is UPDATE type
	UpdatedVersion   *uint64 `protobuf:"varint,5,opt,name=updatedVersion" json:"updatedVersion,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *VersionInfo) Reset()                    { *m = VersionInfo{} }
func (m *VersionInfo) String() string            { return proto.CompactTextString(m) }
func (*VersionInfo) ProtoMessage()               {}
func (*VersionInfo) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *VersionInfo) GetType() VersionInfo_OperationType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return VersionInfo_NEW
}

func (m *VersionInfo) GetIsNullId() bool {
	if m != nil && m.IsNullId != nil {
		return *m.IsNullId
	}
	return false
}

func (m *VersionInfo) GetRemovedVersion() uint64 {
	if m != nil && m.RemovedVersion != nil {
		return *m.RemovedVersion
	}
	return 0
}

func (m *VersionInfo) GetRemovedTime() uint64 {
	if m != nil && m.RemovedTime != nil {
		return *m.RemovedTime
	}
	return 0
}

func (m *VersionInfo) GetUpdatedVersion() uint64 {
	if m != nil && m.UpdatedVersion != nil {
		return *m.UpdatedVersion
	}
	return 0
}

type SystemMetadata struct {
	Key *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	// only 1 or the other
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	BinaryValue      []byte  `protobuf:"bytes,3,opt,name=binaryValue" json:"binaryValue,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SystemMetadata) Reset()                    { *m = SystemMetadata{} }
func (m *SystemMetadata) String() string            { return proto.CompactTextString(m) }
func (*SystemMetadata) ProtoMessage()               {}
func (*SystemMetadata) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *SystemMetadata) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *SystemMetadata) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *SystemMetadata) GetBinaryValue() []byte {
	if m != nil {
		return m.BinaryValue
	}
	return nil
}

type HeadSystemMetadata struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	IsDeleted        *bool   `protobuf:"varint,3,opt,name=isDeleted" json:"isDeleted,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *HeadSystemMetadata) Reset()                    { *m = HeadSystemMetadata{} }
func (m *HeadSystemMetadata) String() string            { return proto.CompactTextString(m) }
func (*HeadSystemMetadata) ProtoMessage()               {}
func (*HeadSystemMetadata) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

func (m *HeadSystemMetadata) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *HeadSystemMetadata) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *HeadSystemMetadata) GetIsDeleted() bool {
	if m != nil && m.IsDeleted != nil {
		return *m.IsDeleted
	}
	return false
}

type UserMetadata struct {
	Key *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	// TODO: possibly add a type field to ensure only one of these is set
	IsDeleted        *bool   `protobuf:"varint,2,opt,name=isDeleted" json:"isDeleted,omitempty"`
	TextValue        *string `protobuf:"bytes,3,opt,name=textValue" json:"textValue,omitempty"`
	BinaryValue      []byte  `protobuf:"bytes,4,opt,name=binaryValue" json:"binaryValue,omitempty"`
	SkipDare         *bool   `protobuf:"varint,5,opt,name=skipDare,def=0" json:"skipDare,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UserMetadata) Reset()                    { *m = UserMetadata{} }
func (m *UserMetadata) String() string            { return proto.CompactTextString(m) }
func (*UserMetadata) ProtoMessage()               {}
func (*UserMetadata) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{3} }

const Default_UserMetadata_SkipDare bool = false

func (m *UserMetadata) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *UserMetadata) GetIsDeleted() bool {
	if m != nil && m.IsDeleted != nil {
		return *m.IsDeleted
	}
	return false
}

func (m *UserMetadata) GetTextValue() string {
	if m != nil && m.TextValue != nil {
		return *m.TextValue
	}
	return ""
}

func (m *UserMetadata) GetBinaryValue() []byte {
	if m != nil {
		return m.BinaryValue
	}
	return nil
}

func (m *UserMetadata) GetSkipDare() bool {
	if m != nil && m.SkipDare != nil {
		return *m.SkipDare
	}
	return Default_UserMetadata_SkipDare
}

type DataRange struct {
	// The '-1' value of the objectOffset means the data offset in the
	// object is unknown. The process needs to construct the full mapping
	// by reading the latest index file and scanning the update files (the
	// latest index version ~ the latest update version).
	ObjectOffset *int64 `protobuf:"varint,1,req,name=objectOffset,def=-1" json:"objectOffset,omitempty"`
	// object data length
	// -1 value for objectLength means the data segment length is unknown.
	// The actual data segment length is determined by reading the size of the
	// file being pointed to and adjusting for the file offset.
	ObjectLength     *uint64 `protobuf:"varint,2,req,name=objectLength" json:"objectLength,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DataRange) Reset()                    { *m = DataRange{} }
func (m *DataRange) String() string            { return proto.CompactTextString(m) }
func (*DataRange) ProtoMessage()               {}
func (*DataRange) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{4} }

const Default_DataRange_ObjectOffset int64 = -1

func (m *DataRange) GetObjectOffset() int64 {
	if m != nil && m.ObjectOffset != nil {
		return *m.ObjectOffset
	}
	return Default_DataRange_ObjectOffset
}

func (m *DataRange) GetObjectLength() uint64 {
	if m != nil && m.ObjectLength != nil {
		return *m.ObjectLength
	}
	return 0
}

type DataIndex struct {
	// updated object segment
	DataRange *DataRange `protobuf:"bytes,1,req,name=dataRange" json:"dataRange,omitempty"`
	// location of the object segment
	// if segment location is null, the object data is stored in the same file along
	// with the the metadata record (UMR/IMR).
	// TODO: enforce these constraints in the code
	SegmentLocation *SegmentLocation `protobuf:"bytes,2,opt,name=segmentLocation" json:"segmentLocation,omitempty"`
	// the priority for this data
	SegmentPriority *int64 `protobuf:"varint,3,req,name=segmentPriority,def=-1" json:"segmentPriority,omitempty"`
	// if isValid is false then it indicates a hole
	IsValid          *bool  `protobuf:"varint,4,opt,name=isValid,def=1" json:"isValid,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DataIndex) Reset()                    { *m = DataIndex{} }
func (m *DataIndex) String() string            { return proto.CompactTextString(m) }
func (*DataIndex) ProtoMessage()               {}
func (*DataIndex) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{5} }

const Default_DataIndex_SegmentPriority int64 = -1
const Default_DataIndex_IsValid bool = true

func (m *DataIndex) GetDataRange() *DataRange {
	if m != nil {
		return m.DataRange
	}
	return nil
}

func (m *DataIndex) GetSegmentLocation() *SegmentLocation {
	if m != nil {
		return m.SegmentLocation
	}
	return nil
}

func (m *DataIndex) GetSegmentPriority() int64 {
	if m != nil && m.SegmentPriority != nil {
		return *m.SegmentPriority
	}
	return Default_DataIndex_SegmentPriority
}

func (m *DataIndex) GetIsValid() bool {
	if m != nil && m.IsValid != nil {
		return *m.IsValid
	}
	return Default_DataIndex_IsValid
}

type LockIndex struct {
	// Range for the lock
	LockRange        *ByteRange `protobuf:"bytes,1,req,name=lockRange" json:"lockRange,omitempty"`
	Lock             *LockInfo  `protobuf:"bytes,2,req,name=lock" json:"lock,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *LockIndex) Reset()                    { *m = LockIndex{} }
func (m *LockIndex) String() string            { return proto.CompactTextString(m) }
func (*LockIndex) ProtoMessage()               {}
func (*LockIndex) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{6} }

func (m *LockIndex) GetLockRange() *ByteRange {
	if m != nil {
		return m.LockRange
	}
	return nil
}

func (m *LockIndex) GetLock() *LockInfo {
	if m != nil {
		return m.Lock
	}
	return nil
}

type LockIndexRecord struct {
	LockRange          *ByteRange   `protobuf:"bytes,1,req,name=lockRange" json:"lockRange,omitempty"`
	LockIndices        []*LockIndex `protobuf:"bytes,2,rep,name=lockIndices" json:"lockIndices,omitempty"`
	HasMoreLockIndices *bool        `protobuf:"varint,3,opt,name=hasMoreLockIndices,def=0" json:"hasMoreLockIndices,omitempty"`
	XXX_unrecognized   []byte       `json:"-"`
}

func (m *LockIndexRecord) Reset()                    { *m = LockIndexRecord{} }
func (m *LockIndexRecord) String() string            { return proto.CompactTextString(m) }
func (*LockIndexRecord) ProtoMessage()               {}
func (*LockIndexRecord) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{7} }

const Default_LockIndexRecord_HasMoreLockIndices bool = false

func (m *LockIndexRecord) GetLockRange() *ByteRange {
	if m != nil {
		return m.LockRange
	}
	return nil
}

func (m *LockIndexRecord) GetLockIndices() []*LockIndex {
	if m != nil {
		return m.LockIndices
	}
	return nil
}

func (m *LockIndexRecord) GetHasMoreLockIndices() bool {
	if m != nil && m.HasMoreLockIndices != nil {
		return *m.HasMoreLockIndices
	}
	return Default_LockIndexRecord_HasMoreLockIndices
}

//
// The metadata record in the index file, include all system
// metadata, user metadata and data indices.
// SS: Too bad GPB doesn't do message type inheritance, otherwise IMR could be a
// derivative of UMR
type IndexMetadataRecord struct {
	SysMd         []*SystemMetadata `protobuf:"bytes,1,rep,name=sysMd" json:"sysMd,omitempty"`
	HasMoreSysMd  *bool             `protobuf:"varint,2,opt,name=hasMoreSysMd,def=0" json:"hasMoreSysMd,omitempty"`
	UserMd        []*UserMetadata   `protobuf:"bytes,3,rep,name=userMd" json:"userMd,omitempty"`
	HasMoreUserMd *bool             `protobuf:"varint,4,opt,name=hasMoreUserMd,def=0" json:"hasMoreUserMd,omitempty"`
	// IndexMetadataRecord may contain at most one of the following:
	// * One data index and no SegmentLocation -- object data is stored inline in the
	//   index file
	// * A list of data indices, each with valid SegmentLocation -- each index
	//   points to a file that contains an object data segment
	// * BPlusTreeRecord -- pointer to the root of a BPlusTree structured data indices.
	//   Note that BPlusTree structured indices are not planned for the near term, and
	//   will be implemented in a later release.
	// If the object does not contain any data, the IndexMetadataRecord will not
	// contain any of the above.
	// TODO: if BPlusTree is not in the horizon for object index maintanance,
	// TODO: we can combine IMR and UMR
	DataIndices        []*DataIndex `protobuf:"bytes,5,rep,name=dataIndices" json:"dataIndices,omitempty"`
	HasMoreDataIndices *bool        `protobuf:"varint,6,opt,name=hasMoreDataIndices,def=0" json:"hasMoreDataIndices,omitempty"`
	// if any of the above booleans is true, then reposIMRLocation contains the list of
	// SegmentLocations of the record written to file
	ReposIMRLocations []*SegmentLocation `protobuf:"bytes,7,rep,name=reposIMRLocations" json:"reposIMRLocations,omitempty"`
	BPlusTreeRecord   *BPlusTreeRecord   `protobuf:"bytes,8,opt,name=bPlusTreeRecord" json:"bPlusTreeRecord,omitempty"`
	// Possibly updated head system metadata in the index file
	HeadSysMd        []*HeadSystemMetadata `protobuf:"bytes,9,rep,name=headSysMd" json:"headSysMd,omitempty"`
	HasMoreHeadSysMd *bool                 `protobuf:"varint,10,opt,name=hasMoreHeadSysMd,def=0" json:"hasMoreHeadSysMd,omitempty"`
	// List of indices pointing to locks for this update
	LockIndices        []*LockIndex `protobuf:"bytes,11,rep,name=lockIndices" json:"lockIndices,omitempty"`
	HasMoreLockIndices *bool        `protobuf:"varint,12,opt,name=hasMoreLockIndices,def=0" json:"hasMoreLockIndices,omitempty"`
	XXX_unrecognized   []byte       `json:"-"`
}

func (m *IndexMetadataRecord) Reset()                    { *m = IndexMetadataRecord{} }
func (m *IndexMetadataRecord) String() string            { return proto.CompactTextString(m) }
func (*IndexMetadataRecord) ProtoMessage()               {}
func (*IndexMetadataRecord) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{8} }

const Default_IndexMetadataRecord_HasMoreSysMd bool = false
const Default_IndexMetadataRecord_HasMoreUserMd bool = false
const Default_IndexMetadataRecord_HasMoreDataIndices bool = false
const Default_IndexMetadataRecord_HasMoreHeadSysMd bool = false
const Default_IndexMetadataRecord_HasMoreLockIndices bool = false

func (m *IndexMetadataRecord) GetSysMd() []*SystemMetadata {
	if m != nil {
		return m.SysMd
	}
	return nil
}

func (m *IndexMetadataRecord) GetHasMoreSysMd() bool {
	if m != nil && m.HasMoreSysMd != nil {
		return *m.HasMoreSysMd
	}
	return Default_IndexMetadataRecord_HasMoreSysMd
}

func (m *IndexMetadataRecord) GetUserMd() []*UserMetadata {
	if m != nil {
		return m.UserMd
	}
	return nil
}

func (m *IndexMetadataRecord) GetHasMoreUserMd() bool {
	if m != nil && m.HasMoreUserMd != nil {
		return *m.HasMoreUserMd
	}
	return Default_IndexMetadataRecord_HasMoreUserMd
}

func (m *IndexMetadataRecord) GetDataIndices() []*DataIndex {
	if m != nil {
		return m.DataIndices
	}
	return nil
}

func (m *IndexMetadataRecord) GetHasMoreDataIndices() bool {
	if m != nil && m.HasMoreDataIndices != nil {
		return *m.HasMoreDataIndices
	}
	return Default_IndexMetadataRecord_HasMoreDataIndices
}

func (m *IndexMetadataRecord) GetReposIMRLocations() []*SegmentLocation {
	if m != nil {
		return m.ReposIMRLocations
	}
	return nil
}

func (m *IndexMetadataRecord) GetBPlusTreeRecord() *BPlusTreeRecord {
	if m != nil {
		return m.BPlusTreeRecord
	}
	return nil
}

func (m *IndexMetadataRecord) GetHeadSysMd() []*HeadSystemMetadata {
	if m != nil {
		return m.HeadSysMd
	}
	return nil
}

func (m *IndexMetadataRecord) GetHasMoreHeadSysMd() bool {
	if m != nil && m.HasMoreHeadSysMd != nil {
		return *m.HasMoreHeadSysMd
	}
	return Default_IndexMetadataRecord_HasMoreHeadSysMd
}

func (m *IndexMetadataRecord) GetLockIndices() []*LockIndex {
	if m != nil {
		return m.LockIndices
	}
	return nil
}

func (m *IndexMetadataRecord) GetHasMoreLockIndices() bool {
	if m != nil && m.HasMoreLockIndices != nil {
		return *m.HasMoreLockIndices
	}
	return Default_IndexMetadataRecord_HasMoreLockIndices
}

type SystemMetadataSet struct {
	SysMd             []*SystemMetadata  `protobuf:"bytes,1,rep,name=sysMd" json:"sysMd,omitempty"`
	HasMoreMetadata   *bool              `protobuf:"varint,2,req,name=hasMoreMetadata,def=0" json:"hasMoreMetadata,omitempty"`
	RepoFileLocations []*SegmentLocation `protobuf:"bytes,3,rep,name=repoFileLocations" json:"repoFileLocations,omitempty"`
	XXX_unrecognized  []byte             `json:"-"`
}

func (m *SystemMetadataSet) Reset()                    { *m = SystemMetadataSet{} }
func (m *SystemMetadataSet) String() string            { return proto.CompactTextString(m) }
func (*SystemMetadataSet) ProtoMessage()               {}
func (*SystemMetadataSet) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{9} }

const Default_SystemMetadataSet_HasMoreMetadata bool = false

func (m *SystemMetadataSet) GetSysMd() []*SystemMetadata {
	if m != nil {
		return m.SysMd
	}
	return nil
}

func (m *SystemMetadataSet) GetHasMoreMetadata() bool {
	if m != nil && m.HasMoreMetadata != nil {
		return *m.HasMoreMetadata
	}
	return Default_SystemMetadataSet_HasMoreMetadata
}

func (m *SystemMetadataSet) GetRepoFileLocations() []*SegmentLocation {
	if m != nil {
		return m.RepoFileLocations
	}
	return nil
}

type UserMetadataSet struct {
	UserMd            []*UserMetadata    `protobuf:"bytes,1,rep,name=userMd" json:"userMd,omitempty"`
	HasMoreMetadata   *bool              `protobuf:"varint,2,req,name=hasMoreMetadata,def=0" json:"hasMoreMetadata,omitempty"`
	RepoFileLocations []*SegmentLocation `protobuf:"bytes,3,rep,name=repoFileLocations" json:"repoFileLocations,omitempty"`
	XXX_unrecognized  []byte             `json:"-"`
}

func (m *UserMetadataSet) Reset()                    { *m = UserMetadataSet{} }
func (m *UserMetadataSet) String() string            { return proto.CompactTextString(m) }
func (*UserMetadataSet) ProtoMessage()               {}
func (*UserMetadataSet) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{10} }

const Default_UserMetadataSet_HasMoreMetadata bool = false

func (m *UserMetadataSet) GetUserMd() []*UserMetadata {
	if m != nil {
		return m.UserMd
	}
	return nil
}

func (m *UserMetadataSet) GetHasMoreMetadata() bool {
	if m != nil && m.HasMoreMetadata != nil {
		return *m.HasMoreMetadata
	}
	return Default_UserMetadataSet_HasMoreMetadata
}

func (m *UserMetadataSet) GetRepoFileLocations() []*SegmentLocation {
	if m != nil {
		return m.RepoFileLocations
	}
	return nil
}

type HeadMetadataSet struct {
	HeadMd            []*HeadSystemMetadata `protobuf:"bytes,1,rep,name=headMd" json:"headMd,omitempty"`
	HasMoreMetadata   *bool                 `protobuf:"varint,2,req,name=hasMoreMetadata,def=0" json:"hasMoreMetadata,omitempty"`
	RepoFileLocations []*SegmentLocation    `protobuf:"bytes,3,rep,name=repoFileLocations" json:"repoFileLocations,omitempty"`
	XXX_unrecognized  []byte                `json:"-"`
}

func (m *HeadMetadataSet) Reset()                    { *m = HeadMetadataSet{} }
func (m *HeadMetadataSet) String() string            { return proto.CompactTextString(m) }
func (*HeadMetadataSet) ProtoMessage()               {}
func (*HeadMetadataSet) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{11} }

const Default_HeadMetadataSet_HasMoreMetadata bool = false

func (m *HeadMetadataSet) GetHeadMd() []*HeadSystemMetadata {
	if m != nil {
		return m.HeadMd
	}
	return nil
}

func (m *HeadMetadataSet) GetHasMoreMetadata() bool {
	if m != nil && m.HasMoreMetadata != nil {
		return *m.HasMoreMetadata
	}
	return Default_HeadMetadataSet_HasMoreMetadata
}

func (m *HeadMetadataSet) GetRepoFileLocations() []*SegmentLocation {
	if m != nil {
		return m.RepoFileLocations
	}
	return nil
}

// This is used to serialize all the overflow metadata into repo file.
type MetadataSet struct {
	HeadMd           []*HeadSystemMetadata `protobuf:"bytes,1,rep,name=headMd" json:"headMd,omitempty"`
	SysMd            []*SystemMetadata     `protobuf:"bytes,2,rep,name=sysMd" json:"sysMd,omitempty"`
	UserMd           []*UserMetadata       `protobuf:"bytes,3,rep,name=userMd" json:"userMd,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *MetadataSet) Reset()                    { *m = MetadataSet{} }
func (m *MetadataSet) String() string            { return proto.CompactTextString(m) }
func (*MetadataSet) ProtoMessage()               {}
func (*MetadataSet) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{12} }

func (m *MetadataSet) GetHeadMd() []*HeadSystemMetadata {
	if m != nil {
		return m.HeadMd
	}
	return nil
}

func (m *MetadataSet) GetSysMd() []*SystemMetadata {
	if m != nil {
		return m.SysMd
	}
	return nil
}

func (m *MetadataSet) GetUserMd() []*UserMetadata {
	if m != nil {
		return m.UserMd
	}
	return nil
}

// This is used to record the process.
// We need to execute the following in sequence:
// 1. update metadata and index range entries.
// 2. update compaction marker.
// 3. insert jobs to delete deprecated entries.
// Use sfixed64 to make overflow calculation simpler.
type CompactionMarker struct {
	LastIndexedSequence *int64 `protobuf:"fixed64,1,req,name=lastIndexedSequence" json:"lastIndexedSequence,omitempty"`
	// Sorted version history, from the latest to the oldest
	// We keep the version history here so that when the last version
	// of the object is removed, we know which one is the (new) current version.
	VersionHistoryDesc []int64 `protobuf:"fixed64,2,rep,name=versionHistoryDesc" json:"versionHistoryDesc,omitempty"`
	// nullVersionStartSequence is used to track the start sequence number of the
	// latest null sequence.
	// If there is a null version before version 1 and then we suspended versioning and
	// create a new null version, we need to update this field so that the next read
	// will not load indexes for the old null version.
	NullVersionStartSequence *int64 `protobuf:"fixed64,3,opt,name=nullVersionStartSequence" json:"nullVersionStartSequence,omitempty"`
	// In case there are lots of versions, this entry can overflow to repo chunks.
	RepoFileLocations []*SegmentLocation                  `protobuf:"bytes,4,rep,name=repoFileLocations" json:"repoFileLocations,omitempty"`
	MarkerVersion     *CompactionMarker_MarkerVersionType `protobuf:"varint,5,opt,name=markerVersion,enum=or.CompactionMarker_MarkerVersionType" json:"markerVersion,omitempty"`
	XXX_unrecognized  []byte                              `json:"-"`
}

func (m *CompactionMarker) Reset()                    { *m = CompactionMarker{} }
func (m *CompactionMarker) String() string            { return proto.CompactTextString(m) }
func (*CompactionMarker) ProtoMessage()               {}
func (*CompactionMarker) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{13} }

func (m *CompactionMarker) GetLastIndexedSequence() int64 {
	if m != nil && m.LastIndexedSequence != nil {
		return *m.LastIndexedSequence
	}
	return 0
}

func (m *CompactionMarker) GetVersionHistoryDesc() []int64 {
	if m != nil {
		return m.VersionHistoryDesc
	}
	return nil
}

func (m *CompactionMarker) GetNullVersionStartSequence() int64 {
	if m != nil && m.NullVersionStartSequence != nil {
		return *m.NullVersionStartSequence
	}
	return 0
}

func (m *CompactionMarker) GetRepoFileLocations() []*SegmentLocation {
	if m != nil {
		return m.RepoFileLocations
	}
	return nil
}

func (m *CompactionMarker) GetMarkerVersion() CompactionMarker_MarkerVersionType {
	if m != nil && m.MarkerVersion != nil {
		return *m.MarkerVersion
	}
	return CompactionMarker_version22
}

type VersionHistory struct {
	Versions         []int64 `protobuf:"fixed64,1,rep,name=versions" json:"versions,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *VersionHistory) Reset()                    { *m = VersionHistory{} }
func (m *VersionHistory) String() string            { return proto.CompactTextString(m) }
func (*VersionHistory) ProtoMessage()               {}
func (*VersionHistory) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{14} }

func (m *VersionHistory) GetVersions() []int64 {
	if m != nil {
		return m.Versions
	}
	return nil
}

//
// The metadata record in the update file.
//
// The update file format:
//   The following metadata record size, 4 bytes (int).
//   Metadata record.
//   Data.
type UpdateMetadataRecord struct {
	// Possibly updated system metadata in the update file
	SysMd        []*SystemMetadata `protobuf:"bytes,1,rep,name=sysMd" json:"sysMd,omitempty"`
	HasMoreSysMd *bool             `protobuf:"varint,2,opt,name=hasMoreSysMd,def=0" json:"hasMoreSysMd,omitempty"`
	// Possibly updated user metadata in the update file
	UserMd        []*UserMetadata `protobuf:"bytes,3,rep,name=userMd" json:"userMd,omitempty"`
	HasMoreUserMd *bool           `protobuf:"varint,4,opt,name=hasMoreUserMd,def=0" json:"hasMoreUserMd,omitempty"`
	// List of indices pointing to data segments that correspond to this update
	DataIndices        []*DataIndex `protobuf:"bytes,5,rep,name=dataIndices" json:"dataIndices,omitempty"`
	HasMoreDataIndices *bool        `protobuf:"varint,6,opt,name=hasMoreDataIndices,def=0" json:"hasMoreDataIndices,omitempty"`
	// if any of the above booleans is true, or if the request contains inline data
	// that is written to repository file, then reposUMRLocations contains the list of
	// SegmentLocations of the record written to file
	ReposUMRLocations []*SegmentLocation `protobuf:"bytes,7,rep,name=reposUMRLocations" json:"reposUMRLocations,omitempty"`
	// Possibly updated head system metadata in the update file
	HeadSysMd        []*HeadSystemMetadata `protobuf:"bytes,8,rep,name=headSysMd" json:"headSysMd,omitempty"`
	HasMoreHeadSysMd *bool                 `protobuf:"varint,9,opt,name=hasMoreHeadSysMd,def=0" json:"hasMoreHeadSysMd,omitempty"`
	// List of indices pointing to locks for this update
	LockIndices        []*LockIndex `protobuf:"bytes,10,rep,name=lockIndices" json:"lockIndices,omitempty"`
	HasMoreLockIndices *bool        `protobuf:"varint,11,opt,name=hasMoreLockIndices,def=0" json:"hasMoreLockIndices,omitempty"`
	XXX_unrecognized   []byte       `json:"-"`
}

func (m *UpdateMetadataRecord) Reset()                    { *m = UpdateMetadataRecord{} }
func (m *UpdateMetadataRecord) String() string            { return proto.CompactTextString(m) }
func (*UpdateMetadataRecord) ProtoMessage()               {}
func (*UpdateMetadataRecord) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{15} }

const Default_UpdateMetadataRecord_HasMoreSysMd bool = false
const Default_UpdateMetadataRecord_HasMoreUserMd bool = false
const Default_UpdateMetadataRecord_HasMoreDataIndices bool = false
const Default_UpdateMetadataRecord_HasMoreHeadSysMd bool = false
const Default_UpdateMetadataRecord_HasMoreLockIndices bool = false

func (m *UpdateMetadataRecord) GetSysMd() []*SystemMetadata {
	if m != nil {
		return m.SysMd
	}
	return nil
}

func (m *UpdateMetadataRecord) GetHasMoreSysMd() bool {
	if m != nil && m.HasMoreSysMd != nil {
		return *m.HasMoreSysMd
	}
	return Default_UpdateMetadataRecord_HasMoreSysMd
}

func (m *UpdateMetadataRecord) GetUserMd() []*UserMetadata {
	if m != nil {
		return m.UserMd
	}
	return nil
}

func (m *UpdateMetadataRecord) GetHasMoreUserMd() bool {
	if m != nil && m.HasMoreUserMd != nil {
		return *m.HasMoreUserMd
	}
	return Default_UpdateMetadataRecord_HasMoreUserMd
}

func (m *UpdateMetadataRecord) GetDataIndices() []*DataIndex {
	if m != nil {
		return m.DataIndices
	}
	return nil
}

func (m *UpdateMetadataRecord) GetHasMoreDataIndices() bool {
	if m != nil && m.HasMoreDataIndices != nil {
		return *m.HasMoreDataIndices
	}
	return Default_UpdateMetadataRecord_HasMoreDataIndices
}

func (m *UpdateMetadataRecord) GetReposUMRLocations() []*SegmentLocation {
	if m != nil {
		return m.ReposUMRLocations
	}
	return nil
}

func (m *UpdateMetadataRecord) GetHeadSysMd() []*HeadSystemMetadata {
	if m != nil {
		return m.HeadSysMd
	}
	return nil
}

func (m *UpdateMetadataRecord) GetHasMoreHeadSysMd() bool {
	if m != nil && m.HasMoreHeadSysMd != nil {
		return *m.HasMoreHeadSysMd
	}
	return Default_UpdateMetadataRecord_HasMoreHeadSysMd
}

func (m *UpdateMetadataRecord) GetLockIndices() []*LockIndex {
	if m != nil {
		return m.LockIndices
	}
	return nil
}

func (m *UpdateMetadataRecord) GetHasMoreLockIndices() bool {
	if m != nil && m.HasMoreLockIndices != nil {
		return *m.HasMoreLockIndices
	}
	return Default_UpdateMetadataRecord_HasMoreLockIndices
}

type CrossReferenceRecord struct {
	VersionId        *string `protobuf:"bytes,1,req,name=versionId" json:"versionId,omitempty"`
	StartOffset      *int64  `protobuf:"varint,2,opt,name=startOffset" json:"startOffset,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CrossReferenceRecord) Reset()                    { *m = CrossReferenceRecord{} }
func (m *CrossReferenceRecord) String() string            { return proto.CompactTextString(m) }
func (*CrossReferenceRecord) ProtoMessage()               {}
func (*CrossReferenceRecord) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{16} }

func (m *CrossReferenceRecord) GetVersionId() string {
	if m != nil && m.VersionId != nil {
		return *m.VersionId
	}
	return ""
}

func (m *CrossReferenceRecord) GetStartOffset() int64 {
	if m != nil && m.StartOffset != nil {
		return *m.StartOffset
	}
	return 0
}

type CleanupJobRecord struct {
	// The segmentLocation to add negative reference
	SegmentLocation []*SegmentLocation `protobuf:"bytes,1,rep,name=segmentLocation" json:"segmentLocation,omitempty"`
	// The last journal region for OB table, at the time of IC
	LastJournalRegion         *DTRecordKey `protobuf:"bytes,2,opt,name=lastJournalRegion" json:"lastJournalRegion,omitempty"`
	OffsetInObjectForSegments []int64      `protobuf:"varint,3,rep,name=offsetInObjectForSegments" json:"offsetInObjectForSegments,omitempty"`
	// Optional field for remove LS entry job.
	// Keypool can be deleted/recreated so we record this at the time of object deletion.
	KeypoolOwnerZone *string `protobuf:"bytes,4,opt,name=keypoolOwnerZone" json:"keypoolOwnerZone,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CleanupJobRecord) Reset()                    { *m = CleanupJobRecord{} }
func (m *CleanupJobRecord) String() string            { return proto.CompactTextString(m) }
func (*CleanupJobRecord) ProtoMessage()               {}
func (*CleanupJobRecord) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{17} }

func (m *CleanupJobRecord) GetSegmentLocation() []*SegmentLocation {
	if m != nil {
		return m.SegmentLocation
	}
	return nil
}

func (m *CleanupJobRecord) GetLastJournalRegion() *DTRecordKey {
	if m != nil {
		return m.LastJournalRegion
	}
	return nil
}

func (m *CleanupJobRecord) GetOffsetInObjectForSegments() []int64 {
	if m != nil {
		return m.OffsetInObjectForSegments
	}
	return nil
}

func (m *CleanupJobRecord) GetKeypoolOwnerZone() string {
	if m != nil && m.KeypoolOwnerZone != nil {
		return *m.KeypoolOwnerZone
	}
	return ""
}

type DeleteAllIndicesJobRecord struct {
	// The last journal region for OB table, at the time of IC
	LastJournalRegion *DTRecordKey `protobuf:"bytes,1,opt,name=lastJournalRegion" json:"lastJournalRegion,omitempty"`
	ObjectSize        *int64       `protobuf:"varint,2,opt,name=objectSize" json:"objectSize,omitempty"`
	XXX_unrecognized  []byte       `json:"-"`
}

func (m *DeleteAllIndicesJobRecord) Reset()                    { *m = DeleteAllIndicesJobRecord{} }
func (m *DeleteAllIndicesJobRecord) String() string            { return proto.CompactTextString(m) }
func (*DeleteAllIndicesJobRecord) ProtoMessage()               {}
func (*DeleteAllIndicesJobRecord) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{18} }

func (m *DeleteAllIndicesJobRecord) GetLastJournalRegion() *DTRecordKey {
	if m != nil {
		return m.LastJournalRegion
	}
	return nil
}

func (m *DeleteAllIndicesJobRecord) GetObjectSize() int64 {
	if m != nil && m.ObjectSize != nil {
		return *m.ObjectSize
	}
	return 0
}

// Object delta record for metering purpose
type ObjectDeltaRecord struct {
	Namespace    *string `protobuf:"bytes,1,req,name=namespace" json:"namespace,omitempty"`
	Keypool      *string `protobuf:"bytes,2,req,name=keypool" json:"keypool,omitempty"`
	BytesRemoved *int64  `protobuf:"varint,3,req,name=bytesRemoved" json:"bytesRemoved,omitempty"`
	IsDelete     *bool   `protobuf:"varint,4,req,name=isDelete" json:"isDelete,omitempty"`
	// Timestamp when IC runs.
	// This is used by metering IC collector to skip entries that are alrady processed.
	IcTimestamp      *int64 `protobuf:"varint,5,req,name=icTimestamp" json:"icTimestamp,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ObjectDeltaRecord) Reset()                    { *m = ObjectDeltaRecord{} }
func (m *ObjectDeltaRecord) String() string            { return proto.CompactTextString(m) }
func (*ObjectDeltaRecord) ProtoMessage()               {}
func (*ObjectDeltaRecord) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{19} }

func (m *ObjectDeltaRecord) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *ObjectDeltaRecord) GetKeypool() string {
	if m != nil && m.Keypool != nil {
		return *m.Keypool
	}
	return ""
}

func (m *ObjectDeltaRecord) GetBytesRemoved() int64 {
	if m != nil && m.BytesRemoved != nil {
		return *m.BytesRemoved
	}
	return 0
}

func (m *ObjectDeltaRecord) GetIsDelete() bool {
	if m != nil && m.IsDelete != nil {
		return *m.IsDelete
	}
	return false
}

func (m *ObjectDeltaRecord) GetIcTimestamp() int64 {
	if m != nil && m.IcTimestamp != nil {
		return *m.IcTimestamp
	}
	return 0
}

// Aggregated Object delta record for metering purpose
type AggregatedObjectDeltaRecord struct {
	BytesRemoved     *int64 `protobuf:"varint,1,req,name=bytesRemoved" json:"bytesRemoved,omitempty"`
	ObjDeleted       *int64 `protobuf:"varint,2,req,name=objDeleted" json:"objDeleted,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *AggregatedObjectDeltaRecord) Reset()                    { *m = AggregatedObjectDeltaRecord{} }
func (m *AggregatedObjectDeltaRecord) String() string            { return proto.CompactTextString(m) }
func (*AggregatedObjectDeltaRecord) ProtoMessage()               {}
func (*AggregatedObjectDeltaRecord) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{20} }

func (m *AggregatedObjectDeltaRecord) GetBytesRemoved() int64 {
	if m != nil && m.BytesRemoved != nil {
		return *m.BytesRemoved
	}
	return 0
}

func (m *AggregatedObjectDeltaRecord) GetObjDeleted() int64 {
	if m != nil && m.ObjDeleted != nil {
		return *m.ObjDeleted
	}
	return 0
}

type ObjectSegmentReference struct {
	ObjectId         *string            `protobuf:"bytes,1,req,name=objectId" json:"objectId,omitempty"`
	VersionId        *string            `protobuf:"bytes,2,req,name=versionId" json:"versionId,omitempty"`
	SegmentLocations []*SegmentLocation `protobuf:"bytes,3,rep,name=segmentLocations" json:"segmentLocations,omitempty"`
	BucketId         *string            `protobuf:"bytes,4,opt,name=bucketId" json:"bucketId,omitempty"`
	ParentOid        *string            `protobuf:"bytes,5,opt,name=parentOid" json:"parentOid,omitempty"`
	ObjectName       *string            `protobuf:"bytes,6,opt,name=objectName" json:"objectName,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *ObjectSegmentReference) Reset()                    { *m = ObjectSegmentReference{} }
func (m *ObjectSegmentReference) String() string            { return proto.CompactTextString(m) }
func (*ObjectSegmentReference) ProtoMessage()               {}
func (*ObjectSegmentReference) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{21} }

func (m *ObjectSegmentReference) GetObjectId() string {
	if m != nil && m.ObjectId != nil {
		return *m.ObjectId
	}
	return ""
}

func (m *ObjectSegmentReference) GetVersionId() string {
	if m != nil && m.VersionId != nil {
		return *m.VersionId
	}
	return ""
}

func (m *ObjectSegmentReference) GetSegmentLocations() []*SegmentLocation {
	if m != nil {
		return m.SegmentLocations
	}
	return nil
}

func (m *ObjectSegmentReference) GetBucketId() string {
	if m != nil && m.BucketId != nil {
		return *m.BucketId
	}
	return ""
}

func (m *ObjectSegmentReference) GetParentOid() string {
	if m != nil && m.ParentOid != nil {
		return *m.ParentOid
	}
	return ""
}

func (m *ObjectSegmentReference) GetObjectName() string {
	if m != nil && m.ObjectName != nil {
		return *m.ObjectName
	}
	return ""
}

type RefTableRebuildTaskValue struct {
	Status     *RefTableRebuildTaskValue_Status `protobuf:"varint,1,req,name=status,enum=or.RefTableRebuildTaskValue_Status" json:"status,omitempty"`
	Checkpoint *SchemaKey                       `protobuf:"bytes,2,opt,name=checkpoint" json:"checkpoint,omitempty"`
	// last journal region of scanned OB
	LastJournalRegion *DTRecordKey `protobuf:"bytes,3,opt,name=lastJournalRegion" json:"lastJournalRegion,omitempty"`
	// A zone where lastJournalRegion field was set
	Zone             *string `protobuf:"bytes,4,opt,name=zone" json:"zone,omitempty"`
	IsFailed         *bool   `protobuf:"varint,5,opt,name=isFailed,def=1" json:"isFailed,omitempty"`
	Version          *int32  `protobuf:"varint,6,opt,name=version,def=0" json:"version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RefTableRebuildTaskValue) Reset()                    { *m = RefTableRebuildTaskValue{} }
func (m *RefTableRebuildTaskValue) String() string            { return proto.CompactTextString(m) }
func (*RefTableRebuildTaskValue) ProtoMessage()               {}
func (*RefTableRebuildTaskValue) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{22} }

const Default_RefTableRebuildTaskValue_IsFailed bool = true
const Default_RefTableRebuildTaskValue_Version int32 = 0

func (m *RefTableRebuildTaskValue) GetStatus() RefTableRebuildTaskValue_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return RefTableRebuildTaskValue_SCHEDULED
}

func (m *RefTableRebuildTaskValue) GetCheckpoint() *SchemaKey {
	if m != nil {
		return m.Checkpoint
	}
	return nil
}

func (m *RefTableRebuildTaskValue) GetLastJournalRegion() *DTRecordKey {
	if m != nil {
		return m.LastJournalRegion
	}
	return nil
}

func (m *RefTableRebuildTaskValue) GetZone() string {
	if m != nil && m.Zone != nil {
		return *m.Zone
	}
	return ""
}

func (m *RefTableRebuildTaskValue) GetIsFailed() bool {
	if m != nil && m.IsFailed != nil {
		return *m.IsFailed
	}
	return Default_RefTableRebuildTaskValue_IsFailed
}

func (m *RefTableRebuildTaskValue) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_RefTableRebuildTaskValue_Version
}

type ReconcileTaskValue struct {
	// the max cleanup job timestamp in index store,
	// used for remove reconcile task
	CleanupJobTime *int64 `protobuf:"varint,1,opt,name=cleanupJobTime" json:"cleanupJobTime,omitempty"`
	// last journal region of index store,
	// used for remove reconcile task
	LastJournalRegion *DTRecordKey `protobuf:"bytes,2,opt,name=lastJournalRegion" json:"lastJournalRegion,omitempty"`
	// cleanup job added for conflict part, not present means false
	ConflictCleaned  *bool  `protobuf:"varint,3,opt,name=conflictCleaned" json:"conflictCleaned,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ReconcileTaskValue) Reset()                    { *m = ReconcileTaskValue{} }
func (m *ReconcileTaskValue) String() string            { return proto.CompactTextString(m) }
func (*ReconcileTaskValue) ProtoMessage()               {}
func (*ReconcileTaskValue) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{23} }

func (m *ReconcileTaskValue) GetCleanupJobTime() int64 {
	if m != nil && m.CleanupJobTime != nil {
		return *m.CleanupJobTime
	}
	return 0
}

func (m *ReconcileTaskValue) GetLastJournalRegion() *DTRecordKey {
	if m != nil {
		return m.LastJournalRegion
	}
	return nil
}

func (m *ReconcileTaskValue) GetConflictCleaned() bool {
	if m != nil && m.ConflictCleaned != nil {
		return *m.ConflictCleaned
	}
	return false
}

type ListableTagPayload struct {
	UserTags         []*UserListableTags `protobuf:"bytes,1,rep,name=userTags" json:"userTags,omitempty"`
	ForDelete        *bool               `protobuf:"varint,2,opt,name=forDelete" json:"forDelete,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *ListableTagPayload) Reset()                    { *m = ListableTagPayload{} }
func (m *ListableTagPayload) String() string            { return proto.CompactTextString(m) }
func (*ListableTagPayload) ProtoMessage()               {}
func (*ListableTagPayload) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{24} }

func (m *ListableTagPayload) GetUserTags() []*UserListableTags {
	if m != nil {
		return m.UserTags
	}
	return nil
}

func (m *ListableTagPayload) GetForDelete() bool {
	if m != nil && m.ForDelete != nil {
		return *m.ForDelete
	}
	return false
}

type UserListableTags struct {
	UserId           *string             `protobuf:"bytes,1,req,name=userId" json:"userId,omitempty"`
	Tags             []*ListableTagEntry `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *UserListableTags) Reset()                    { *m = UserListableTags{} }
func (m *UserListableTags) String() string            { return proto.CompactTextString(m) }
func (*UserListableTags) ProtoMessage()               {}
func (*UserListableTags) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{25} }

func (m *UserListableTags) GetUserId() string {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return ""
}

func (m *UserListableTags) GetTags() []*ListableTagEntry {
	if m != nil {
		return m.Tags
	}
	return nil
}

type ListableTagEntry struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ListableTagEntry) Reset()                    { *m = ListableTagEntry{} }
func (m *ListableTagEntry) String() string            { return proto.CompactTextString(m) }
func (*ListableTagEntry) ProtoMessage()               {}
func (*ListableTagEntry) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{26} }

func (m *ListableTagEntry) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ListableTagEntry) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type ListableTagUpgradeFSToken struct {
	Token            *SchemaKey `protobuf:"bytes,1,req,name=token" json:"token,omitempty"`
	OwnerZone        *string    `protobuf:"bytes,2,opt,name=ownerZone" json:"ownerZone,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *ListableTagUpgradeFSToken) Reset()                    { *m = ListableTagUpgradeFSToken{} }
func (m *ListableTagUpgradeFSToken) String() string            { return proto.CompactTextString(m) }
func (*ListableTagUpgradeFSToken) ProtoMessage()               {}
func (*ListableTagUpgradeFSToken) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{27} }

func (m *ListableTagUpgradeFSToken) GetToken() *SchemaKey {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *ListableTagUpgradeFSToken) GetOwnerZone() string {
	if m != nil && m.OwnerZone != nil {
		return *m.OwnerZone
	}
	return ""
}

type ListableTagUpgradeLSTaskValue struct {
	// LS listing trigger and flag
	IsFinished *bool `protobuf:"varint,1,req,name=isFinished" json:"isFinished,omitempty"`
	// keypool full name
	KeypoolFullName *string `protobuf:"bytes,2,req,name=keypoolFullName" json:"keypoolFullName,omitempty"`
	// LS KP listing token
	ScanKPToken *SchemaKey `protobuf:"bytes,3,opt,name=scanKPToken" json:"scanKPToken,omitempty"`
	// LS FS listing token
	ScanFSToken      []*ListableTagUpgradeFSToken `protobuf:"bytes,4,rep,name=scanFSToken" json:"scanFSToken,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *ListableTagUpgradeLSTaskValue) Reset()                    { *m = ListableTagUpgradeLSTaskValue{} }
func (m *ListableTagUpgradeLSTaskValue) String() string            { return proto.CompactTextString(m) }
func (*ListableTagUpgradeLSTaskValue) ProtoMessage()               {}
func (*ListableTagUpgradeLSTaskValue) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{28} }

func (m *ListableTagUpgradeLSTaskValue) GetIsFinished() bool {
	if m != nil && m.IsFinished != nil {
		return *m.IsFinished
	}
	return false
}

func (m *ListableTagUpgradeLSTaskValue) GetKeypoolFullName() string {
	if m != nil && m.KeypoolFullName != nil {
		return *m.KeypoolFullName
	}
	return ""
}

func (m *ListableTagUpgradeLSTaskValue) GetScanKPToken() *SchemaKey {
	if m != nil {
		return m.ScanKPToken
	}
	return nil
}

func (m *ListableTagUpgradeLSTaskValue) GetScanFSToken() []*ListableTagUpgradeFSToken {
	if m != nil {
		return m.ScanFSToken
	}
	return nil
}

type ListableTagUpgradeRTTaskProgress struct {
	NumAllBuckets      *int64     `protobuf:"varint,1,req,name=numAllBuckets" json:"numAllBuckets,omitempty"`
	NumUpgradedBuckets *int64     `protobuf:"varint,2,req,name=numUpgradedBuckets" json:"numUpgradedBuckets,omitempty"`
	ScannerToken       *SchemaKey `protobuf:"bytes,3,req,name=scannerToken" json:"scannerToken,omitempty"`
	XXX_unrecognized   []byte     `json:"-"`
}

func (m *ListableTagUpgradeRTTaskProgress) Reset()         { *m = ListableTagUpgradeRTTaskProgress{} }
func (m *ListableTagUpgradeRTTaskProgress) String() string { return proto.CompactTextString(m) }
func (*ListableTagUpgradeRTTaskProgress) ProtoMessage()    {}
func (*ListableTagUpgradeRTTaskProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor3, []int{29}
}

func (m *ListableTagUpgradeRTTaskProgress) GetNumAllBuckets() int64 {
	if m != nil && m.NumAllBuckets != nil {
		return *m.NumAllBuckets
	}
	return 0
}

func (m *ListableTagUpgradeRTTaskProgress) GetNumUpgradedBuckets() int64 {
	if m != nil && m.NumUpgradedBuckets != nil {
		return *m.NumUpgradedBuckets
	}
	return 0
}

func (m *ListableTagUpgradeRTTaskProgress) GetScannerToken() *SchemaKey {
	if m != nil {
		return m.ScannerToken
	}
	return nil
}

type ListableTagUpgradeRTTaskValue struct {
	// RT scan flag
	IsFinished *bool `protobuf:"varint,1,req,name=isFinished" json:"isFinished,omitempty"`
	// RT scan progress
	ScanProgress     *ListableTagUpgradeRTTaskProgress `protobuf:"bytes,2,opt,name=scanProgress" json:"scanProgress,omitempty"`
	XXX_unrecognized []byte                            `json:"-"`
}

func (m *ListableTagUpgradeRTTaskValue) Reset()                    { *m = ListableTagUpgradeRTTaskValue{} }
func (m *ListableTagUpgradeRTTaskValue) String() string            { return proto.CompactTextString(m) }
func (*ListableTagUpgradeRTTaskValue) ProtoMessage()               {}
func (*ListableTagUpgradeRTTaskValue) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{30} }

func (m *ListableTagUpgradeRTTaskValue) GetIsFinished() bool {
	if m != nil && m.IsFinished != nil {
		return *m.IsFinished
	}
	return false
}

func (m *ListableTagUpgradeRTTaskValue) GetScanProgress() *ListableTagUpgradeRTTaskProgress {
	if m != nil {
		return m.ScanProgress
	}
	return nil
}

func init() {
	proto.RegisterType((*VersionInfo)(nil), "or.VersionInfo")
	proto.RegisterType((*SystemMetadata)(nil), "or.SystemMetadata")
	proto.RegisterType((*HeadSystemMetadata)(nil), "or.HeadSystemMetadata")
	proto.RegisterType((*UserMetadata)(nil), "or.UserMetadata")
	proto.RegisterType((*DataRange)(nil), "or.DataRange")
	proto.RegisterType((*DataIndex)(nil), "or.DataIndex")
	proto.RegisterType((*LockIndex)(nil), "or.LockIndex")
	proto.RegisterType((*LockIndexRecord)(nil), "or.LockIndexRecord")
	proto.RegisterType((*IndexMetadataRecord)(nil), "or.IndexMetadataRecord")
	proto.RegisterType((*SystemMetadataSet)(nil), "or.SystemMetadataSet")
	proto.RegisterType((*UserMetadataSet)(nil), "or.UserMetadataSet")
	proto.RegisterType((*HeadMetadataSet)(nil), "or.HeadMetadataSet")
	proto.RegisterType((*MetadataSet)(nil), "or.MetadataSet")
	proto.RegisterType((*CompactionMarker)(nil), "or.CompactionMarker")
	proto.RegisterType((*VersionHistory)(nil), "or.VersionHistory")
	proto.RegisterType((*UpdateMetadataRecord)(nil), "or.UpdateMetadataRecord")
	proto.RegisterType((*CrossReferenceRecord)(nil), "or.CrossReferenceRecord")
	proto.RegisterType((*CleanupJobRecord)(nil), "or.CleanupJobRecord")
	proto.RegisterType((*DeleteAllIndicesJobRecord)(nil), "or.DeleteAllIndicesJobRecord")
	proto.RegisterType((*ObjectDeltaRecord)(nil), "or.ObjectDeltaRecord")
	proto.RegisterType((*AggregatedObjectDeltaRecord)(nil), "or.AggregatedObjectDeltaRecord")
	proto.RegisterType((*ObjectSegmentReference)(nil), "or.ObjectSegmentReference")
	proto.RegisterType((*RefTableRebuildTaskValue)(nil), "or.RefTableRebuildTaskValue")
	proto.RegisterType((*ReconcileTaskValue)(nil), "or.ReconcileTaskValue")
	proto.RegisterType((*ListableTagPayload)(nil), "or.ListableTagPayload")
	proto.RegisterType((*UserListableTags)(nil), "or.UserListableTags")
	proto.RegisterType((*ListableTagEntry)(nil), "or.ListableTagEntry")
	proto.RegisterType((*ListableTagUpgradeFSToken)(nil), "or.ListableTagUpgradeFSToken")
	proto.RegisterType((*ListableTagUpgradeLSTaskValue)(nil), "or.ListableTagUpgradeLSTaskValue")
	proto.RegisterType((*ListableTagUpgradeRTTaskProgress)(nil), "or.ListableTagUpgradeRTTaskProgress")
	proto.RegisterType((*ListableTagUpgradeRTTaskValue)(nil), "or.ListableTagUpgradeRTTaskValue")
	proto.RegisterEnum("or.VersionInfo_OperationType", VersionInfo_OperationType_name, VersionInfo_OperationType_value)
	proto.RegisterEnum("or.CompactionMarker_MarkerVersionType", CompactionMarker_MarkerVersionType_name, CompactionMarker_MarkerVersionType_value)
	proto.RegisterEnum("or.RefTableRebuildTaskValue_Status", RefTableRebuildTaskValue_Status_name, RefTableRebuildTaskValue_Status_value)
}

func init() { proto.RegisterFile("ObjectRecords.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 1867 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcd, 0x6e, 0xe3, 0xc8,
	0x11, 0x5e, 0x52, 0xb2, 0x2d, 0x96, 0xfc, 0x43, 0xf7, 0x18, 0x86, 0xe6, 0x17, 0x5a, 0xee, 0x62,
	0xe0, 0x64, 0x77, 0xbd, 0x33, 0x46, 0x72, 0x71, 0x76, 0xb1, 0xb0, 0x47, 0x32, 0xec, 0x1d, 0x6b,
	0x6c, 0xb4, 0x64, 0x2f, 0x30, 0x87, 0x00, 0x6d, 0xb2, 0x2d, 0x33, 0xa2, 0x48, 0x85, 0xdd, 0x9a,
	0xac, 0xe6, 0x0d, 0x02, 0xe4, 0x92, 0x47, 0xc8, 0x21, 0xb9, 0x04, 0x41, 0x90, 0x43, 0x4e, 0x01,
	0x72, 0xcb, 0x53, 0xe4, 0x9c, 0x63, 0x5e, 0x20, 0xc8, 0x21, 0xe8, 0x1f, 0x91, 0x4d, 0x4a, 0x5e,
	0xdb, 0x33, 0x87, 0xb9, 0xe4, 0x46, 0xd6, 0x5f, 0x57, 0x55, 0x7f, 0x55, 0xd5, 0xdd, 0x70, 0xef,
	0xe4, 0xe2, 0x17, 0xd4, 0xe7, 0x98, 0xfa, 0x49, 0x1a, 0xb0, 0xed, 0x51, 0x9a, 0xf0, 0x04, 0xd9,
	0x49, 0xfa, 0xe0, 0x61, 0x97, 0xf6, 0x87, 0x34, 0xe6, 0xc7, 0x89, 0x4f, 0x78, 0x98, 0xc4, 0x4a,
	0x42, 0x09, 0x3c, 0xd8, 0xdc, 0x3f, 0x8d, 0xc6, 0xac, 0x97, 0x52, 0x5a, 0x50, 0x7c, 0xb0, 0xd9,
	0xf5, 0xaf, 0xe8, 0x90, 0xbc, 0xa4, 0x93, 0x22, 0x7d, 0xe3, 0x38, 0xf1, 0x07, 0x47, 0xf1, 0x65,
	0x62, 0x5a, 0xf1, 0x7e, 0x63, 0x43, 0xfd, 0x9c, 0xa6, 0x2c, 0x4c, 0x62, 0xc1, 0x43, 0xcf, 0xa1,
	0xca, 0x27, 0x23, 0xda, 0xb0, 0x9a, 0xf6, 0xd6, 0xea, 0xce, 0xe3, 0xed, 0x24, 0xdd, 0x36, 0xd8,
	0xdb, 0x27, 0x23, 0x9a, 0x4a, 0x57, 0x7a, 0x93, 0x11, 0xc5, 0x52, 0x14, 0x3d, 0x80, 0x5a, 0xc8,
	0x5e, 0x8d, 0xa3, 0xe8, 0x28, 0x68, 0xd8, 0x4d, 0x6b, 0xab, 0x86, 0xb3, 0x7f, 0xf4, 0x14, 0x56,
	0x53, 0x3a, 0x4c, 0xde, 0xd0, 0x40, 0x5b, 0x69, 0x54, 0x9a, 0xd6, 0x56, 0x15, 0x97, 0xa8, 0xa8,
	0x09, 0x75, 0x4d, 0xe9, 0x85, 0x43, 0xda, 0xa8, 0x4a, 0x21, 0x93, 0x24, 0x2c, 0x8d, 0x47, 0x01,
	0xe1, 0xb9, 0xa5, 0x05, 0x65, 0xa9, 0x48, 0xf5, 0xbe, 0x82, 0x95, 0x82, 0x93, 0x68, 0x09, 0x2a,
	0xaf, 0xda, 0xdf, 0xb9, 0x1f, 0x21, 0x80, 0xc5, 0xce, 0x1e, 0x7e, 0xd9, 0xc6, 0xae, 0x25, 0xbe,
	0x71, 0xbb, 0x73, 0x72, 0xde, 0x76, 0x6d, 0xf1, 0x7d, 0x76, 0xda, 0xda, 0xeb, 0xb5, 0xdd, 0x8a,
	0xf7, 0x1a, 0x56, 0xbb, 0x13, 0xc6, 0xe9, 0xb0, 0x43, 0x39, 0x09, 0x08, 0x27, 0xc8, 0x85, 0xca,
	0x80, 0x4e, 0x64, 0x3e, 0x1c, 0x2c, 0x3e, 0xd1, 0x06, 0x2c, 0xbc, 0x21, 0xd1, 0x98, 0xca, 0x60,
	0x1d, 0xac, 0x7e, 0x44, 0x04, 0x17, 0x61, 0x4c, 0xd2, 0xc9, 0xb9, 0xe4, 0x89, 0x30, 0x97, 0xb1,
	0x49, 0xf2, 0x5e, 0x03, 0x3a, 0xa4, 0x24, 0x78, 0x47, 0xfb, 0x8f, 0xc0, 0x09, 0x59, 0x8b, 0x46,
	0x94, 0xd3, 0x40, 0x5a, 0xaf, 0xe1, 0x9c, 0xe0, 0xfd, 0xce, 0x82, 0xe5, 0x33, 0x46, 0xd3, 0x1f,
	0x30, 0x5b, 0x30, 0x60, 0x97, 0x0c, 0x08, 0x2e, 0xa7, 0xdf, 0xf3, 0xdc, 0x79, 0x07, 0xe7, 0x84,
	0x72, 0x70, 0xd5, 0x99, 0xe0, 0xd0, 0xc7, 0x50, 0x63, 0x83, 0x70, 0xd4, 0x22, 0x29, 0x95, 0x1b,
	0x53, 0xdb, 0x5d, 0xb8, 0x24, 0x11, 0xa3, 0x38, 0x23, 0x7b, 0xdf, 0x81, 0xd3, 0x22, 0x9c, 0x60,
	0x12, 0xf7, 0xc5, 0x76, 0x2e, 0x27, 0x12, 0xf5, 0x27, 0x97, 0x97, 0x8c, 0x72, 0xe9, 0x68, 0x65,
	0xd7, 0xfe, 0xe2, 0x39, 0x2e, 0xd0, 0x91, 0x37, 0x95, 0x3b, 0xa6, 0x71, 0x9f, 0x5f, 0x35, 0xec,
	0xa6, 0xbd, 0x55, 0xc5, 0x05, 0x9a, 0xf7, 0x0f, 0x4b, 0x59, 0x3e, 0x8a, 0x03, 0xfa, 0x3d, 0xfa,
	0x0c, 0x9c, 0x60, 0xba, 0x8c, 0x34, 0x5b, 0xdf, 0x59, 0x11, 0x30, 0xce, 0xd6, 0xc6, 0x39, 0x1f,
	0x7d, 0x0d, 0x6b, 0xac, 0x58, 0x63, 0x32, 0x35, 0xf5, 0x9d, 0x7b, 0x42, 0xa5, 0x5c, 0x7e, 0x65,
	0x59, 0xf4, 0x79, 0xa6, 0x7e, 0x9a, 0x86, 0x49, 0x1a, 0xf2, 0x49, 0xa3, 0x92, 0x05, 0x52, 0x66,
	0xa1, 0x27, 0xb0, 0x14, 0xb2, 0x73, 0x12, 0x85, 0x81, 0xcc, 0x60, 0x6d, 0xb7, 0xca, 0xd3, 0x31,
	0xc5, 0x53, 0xa2, 0xf7, 0x1a, 0x1c, 0x55, 0xa3, 0x3a, 0x8c, 0x28, 0xf1, 0x07, 0x33, 0x61, 0xec,
	0x4f, 0x38, 0xd5, 0x61, 0x64, 0x7c, 0xd4, 0x84, 0xaa, 0xf8, 0x91, 0xd9, 0xa9, 0xef, 0x2c, 0x0b,
	0xb9, 0xac, 0xda, 0x25, 0xc7, 0xfb, 0x83, 0x05, 0x6b, 0x99, 0x71, 0xd5, 0x01, 0xee, 0xb6, 0xc4,
	0x97, 0x50, 0x8f, 0x94, 0x7e, 0xe8, 0x53, 0xd6, 0xb0, 0x9b, 0x95, 0xa9, 0x78, 0x6e, 0xd6, 0x94,
	0x40, 0x3f, 0x05, 0x74, 0x45, 0x58, 0x27, 0x49, 0xe9, 0xb1, 0xa1, 0x57, 0x31, 0xb1, 0x31, 0x47,
	0xc0, 0xfb, 0x6f, 0x15, 0xee, 0x49, 0x6b, 0x53, 0x28, 0x6b, 0x67, 0xb7, 0x60, 0x81, 0x4d, 0x58,
	0x27, 0x68, 0x58, 0x72, 0x65, 0x24, 0xf7, 0xa7, 0x50, 0x4a, 0x58, 0x09, 0xa0, 0x1f, 0xc1, 0xb2,
	0xb6, 0xdb, 0x95, 0x0a, 0xb6, 0xb9, 0x64, 0x81, 0x85, 0xb6, 0x60, 0x71, 0x2c, 0xaa, 0x46, 0x54,
	0x94, 0xb0, 0xea, 0x0a, 0xab, 0x66, 0x1d, 0x61, 0xcd, 0x47, 0x9f, 0xc1, 0x8a, 0xd6, 0x3c, 0x53,
	0x0a, 0x55, 0xd3, 0x6a, 0x91, 0x27, 0x72, 0x15, 0x28, 0x3c, 0xca, 0x98, 0x17, 0xf2, 0x5c, 0x65,
	0x30, 0xc5, 0xa6, 0x84, 0x91, 0xab, 0x96, 0xa1, 0xb7, 0x38, 0x2f, 0x57, 0x86, 0x00, 0xda, 0x83,
	0xf5, 0x94, 0x8e, 0x12, 0x76, 0xd4, 0xc1, 0x53, 0x48, 0xb2, 0xc6, 0x92, 0x5c, 0x6d, 0x2e, 0x7e,
	0x67, 0xa5, 0x45, 0x01, 0x5c, 0x14, 0xe7, 0x48, 0xa3, 0x96, 0x17, 0x40, 0x69, 0xc4, 0xe0, 0xb2,
	0x2c, 0xfa, 0x09, 0x38, 0x57, 0xaa, 0xa7, 0x75, 0x82, 0x86, 0x23, 0x57, 0xde, 0x14, 0x8a, 0xb3,
	0x8d, 0x0e, 0xe7, 0x82, 0xe8, 0x39, 0xb8, 0x3a, 0x9a, 0xc3, 0x4c, 0x19, 0xcc, 0x60, 0x67, 0xd8,
	0x65, 0xf8, 0xd5, 0xdf, 0x11, 0x7e, 0xcb, 0x37, 0xc1, 0xef, 0x2f, 0x16, 0xac, 0x17, 0x1d, 0xef,
	0x52, 0x7e, 0x07, 0xf0, 0x7d, 0x09, 0x6b, 0xda, 0xea, 0x94, 0x23, 0x8b, 0x32, 0x5b, 0xb3, 0xcc,
	0x9d, 0xee, 0xe1, 0x41, 0x18, 0xd1, 0x7c, 0x0f, 0x2b, 0x37, 0xec, 0x61, 0x41, 0xda, 0xfb, 0xb3,
	0x05, 0x6b, 0x26, 0x68, 0x95, 0xc7, 0x53, 0x64, 0x5b, 0x37, 0x20, 0xfb, 0x43, 0x78, 0xfc, 0x57,
	0x0b, 0xd6, 0xc4, 0xde, 0x9a, 0x1e, 0x6f, 0xc3, 0xa2, 0x40, 0x48, 0xe6, 0xf1, 0x75, 0x38, 0xd2,
	0x52, 0x1f, 0xc4, 0xef, 0xdf, 0x5a, 0x50, 0x7f, 0x1f, 0x9f, 0x33, 0x1c, 0xd9, 0x37, 0xe1, 0xe8,
	0xd6, 0x9d, 0xc9, 0xfb, 0x97, 0x0d, 0xee, 0x8b, 0x64, 0x38, 0x22, 0xbe, 0xf0, 0xb1, 0x43, 0xd2,
	0x01, 0x4d, 0xd1, 0x33, 0xb8, 0x17, 0x11, 0xc6, 0x65, 0x5d, 0xd0, 0xa0, 0x4b, 0x7f, 0x39, 0xa6,
	0xb1, 0xaf, 0x9a, 0xbc, 0x8b, 0xe7, 0xb1, 0xd0, 0x36, 0xa0, 0x37, 0xea, 0x08, 0x75, 0x18, 0x32,
	0x9e, 0xa4, 0x93, 0x16, 0x65, 0xbe, 0xf4, 0xd3, 0xc5, 0x73, 0x38, 0x68, 0x17, 0x1a, 0xf1, 0x38,
	0x8a, 0xf4, 0xb1, 0xab, 0xcb, 0x49, 0xca, 0xb3, 0x65, 0x44, 0x93, 0x77, 0xf1, 0xb5, 0xfc, 0xf9,
	0x3b, 0x51, 0xbd, 0xcb, 0x4e, 0xa0, 0x63, 0x58, 0x19, 0xca, 0x50, 0xcd, 0xd3, 0xe0, 0xea, 0xce,
	0x53, 0xa1, 0x5e, 0xce, 0xc6, 0x76, 0xc7, 0x94, 0x94, 0x27, 0xd7, 0xa2, 0xb2, 0xe7, 0xc1, 0xfa,
	0x8c, 0x0c, 0x5a, 0x01, 0x47, 0xc7, 0xbd, 0xb3, 0xe3, 0x7e, 0xe4, 0x7d, 0x0e, 0xab, 0xe7, 0x85,
	0x34, 0x88, 0x83, 0xaf, 0x16, 0x60, 0x72, 0xff, 0x5d, 0x9c, 0xfd, 0x7b, 0x7f, 0xaf, 0xc2, 0xc6,
	0x99, 0x3c, 0x99, 0xfe, 0x7f, 0x8e, 0xdd, 0x7a, 0x8e, 0x9d, 0xdd, 0x69, 0x8e, 0x99, 0xd2, 0xc5,
	0x41, 0x54, 0x7b, 0x9f, 0x41, 0xe4, 0xdc, 0x69, 0x10, 0xc1, 0x3b, 0x0e, 0xa2, 0xfa, 0x4d, 0x83,
	0xe8, 0x1c, 0x36, 0x5e, 0xa4, 0x09, 0x63, 0x98, 0x5e, 0xd2, 0x54, 0x54, 0x8d, 0xc6, 0xcf, 0xa3,
	0x0c, 0x95, 0x47, 0x81, 0x3e, 0xde, 0xe7, 0x04, 0x71, 0x50, 0x67, 0xa2, 0xd4, 0xf4, 0xa9, 0x5a,
	0x40, 0xa6, 0x82, 0x4d, 0x92, 0xf7, 0x1f, 0x0b, 0xdc, 0x17, 0x11, 0x25, 0xf1, 0x78, 0xf4, 0x6d,
	0x72, 0xa1, 0x8d, 0xce, 0x39, 0x06, 0x5b, 0xd7, 0xa7, 0x7f, 0xe6, 0x18, 0xfc, 0x35, 0xac, 0x8b,
	0x96, 0xf2, 0x6d, 0x32, 0x4e, 0x63, 0x12, 0x61, 0xda, 0xcf, 0xcf, 0xd1, 0x6b, 0x12, 0x2d, 0x3d,
	0xb5, 0x8e, 0xb8, 0x93, 0xce, 0x4a, 0xa2, 0xaf, 0xe0, 0x7e, 0x22, 0x9d, 0x3b, 0x8a, 0xd5, 0x4d,
	0xf8, 0x20, 0x49, 0xf5, 0x9a, 0xaa, 0x41, 0x57, 0xf0, 0xf5, 0x02, 0xe8, 0xc7, 0xe0, 0x0e, 0xe8,
	0x64, 0x94, 0x24, 0xd1, 0xc9, 0xaf, 0x62, 0x9a, 0xbe, 0x4e, 0x62, 0x75, 0x41, 0x71, 0xf0, 0x0c,
	0xdd, 0x7b, 0x0b, 0xf7, 0xd5, 0x85, 0x67, 0x2f, 0x8a, 0x74, 0xa2, 0xcd, 0x24, 0xcc, 0x89, 0xc2,
	0xba, 0x75, 0x14, 0x4f, 0x00, 0xd4, 0xad, 0xa4, 0x1b, 0xbe, 0xa5, 0x3a, 0xf3, 0x06, 0xc5, 0xfb,
	0x93, 0x05, 0xeb, 0xca, 0xfb, 0x16, 0x8d, 0xb2, 0x76, 0xf0, 0x08, 0x9c, 0x98, 0x0c, 0x29, 0x1b,
	0x11, 0xdd, 0x9e, 0x1d, 0x9c, 0x13, 0x50, 0x03, 0x96, 0x74, 0x0c, 0x72, 0xb6, 0x39, 0x78, 0xfa,
	0x2b, 0xee, 0x45, 0x17, 0x13, 0x4e, 0x19, 0x56, 0x57, 0x64, 0x75, 0xed, 0xc0, 0x05, 0x9a, 0xba,
	0x98, 0xab, 0x78, 0x1b, 0x55, 0x31, 0x1a, 0x71, 0xf6, 0x2f, 0x80, 0x12, 0xfa, 0xe2, 0x62, 0xcd,
	0x38, 0x19, 0x8e, 0x1a, 0x0b, 0x52, 0xdd, 0x24, 0x79, 0x04, 0x1e, 0xee, 0xf5, 0xfb, 0x29, 0xed,
	0x8b, 0xdb, 0xf5, 0xac, 0xe3, 0x65, 0x07, 0xac, 0x39, 0x0e, 0xa8, 0x94, 0xe4, 0x77, 0x4e, 0x5b,
	0xa7, 0x64, 0x7a, 0x6b, 0xfd, 0xb7, 0x05, 0x9b, 0xca, 0xb2, 0xde, 0xcd, 0x0c, 0xec, 0xc2, 0x77,
	0x95, 0xbb, 0x0c, 0xe5, 0xd9, 0x7f, 0xb1, 0x04, 0xec, 0x72, 0x09, 0x7c, 0x03, 0x6e, 0x09, 0x9f,
	0x3f, 0x38, 0xe5, 0x67, 0x84, 0xc5, 0xd2, 0x17, 0x63, 0x7f, 0x40, 0xc5, 0xd2, 0x0a, 0x48, 0xd9,
	0xbf, 0x58, 0x7a, 0x44, 0x52, 0x1a, 0xf3, 0x93, 0x30, 0x90, 0x23, 0xc7, 0xc1, 0x39, 0x21, 0x87,
	0xc0, 0x2b, 0x32, 0xa4, 0xb2, 0xed, 0x39, 0xd8, 0xa0, 0x78, 0x7f, 0xb3, 0xa1, 0x81, 0xe9, 0x65,
	0x8f, 0x5c, 0x44, 0x14, 0xd3, 0x8b, 0x71, 0x18, 0x05, 0x3d, 0xc2, 0x06, 0xea, 0x06, 0xfd, 0x33,
	0x58, 0x64, 0x9c, 0xf0, 0x31, 0xd3, 0x6f, 0x2f, 0x9f, 0x08, 0x6f, 0xaf, 0x93, 0xde, 0xee, 0x4a,
	0x51, 0xac, 0x55, 0xd0, 0x17, 0x00, 0xfe, 0x15, 0xf5, 0x07, 0xa3, 0x24, 0x8c, 0xb9, 0x2e, 0x3d,
	0xd9, 0x94, 0xf2, 0xc7, 0x20, 0x43, 0x60, 0x3e, 0xd4, 0x2b, 0xb7, 0x86, 0x3a, 0x82, 0xea, 0xdb,
	0xbc, 0xcc, 0xe4, 0x37, 0x6a, 0x0a, 0xb0, 0x1d, 0x90, 0x30, 0xa2, 0x81, 0x7e, 0x00, 0x50, 0xb7,
	0xdb, 0x8c, 0x8a, 0x1e, 0xc2, 0x92, 0xde, 0x25, 0x99, 0x9a, 0x85, 0x5d, 0xeb, 0x19, 0x9e, 0x52,
	0xbc, 0x8f, 0x61, 0x51, 0x85, 0x24, 0xc6, 0x6e, 0xf7, 0xc5, 0x61, 0xbb, 0x75, 0x76, 0xdc, 0x6e,
	0xb9, 0x16, 0xaa, 0x41, 0xb5, 0x75, 0xf2, 0xaa, 0xed, 0xda, 0xde, 0xef, 0x2d, 0x40, 0xc2, 0xad,
	0xd8, 0x0f, 0x23, 0x9a, 0xe7, 0xed, 0x29, 0xac, 0xfa, 0x59, 0x3f, 0x93, 0xaf, 0x47, 0x96, 0xac,
	0xbd, 0x12, 0xf5, 0x7d, 0x9b, 0xd4, 0x16, 0xac, 0xf9, 0x49, 0x7c, 0x19, 0x85, 0x3e, 0x97, 0xed,
	0x33, 0x7b, 0x85, 0x29, 0x93, 0xbd, 0x00, 0xd0, 0x71, 0xc8, 0xb8, 0xd8, 0xb6, 0x1e, 0xe9, 0x9f,
	0x92, 0x49, 0x94, 0x90, 0x00, 0x3d, 0x83, 0x9a, 0x18, 0xc1, 0x3d, 0xd2, 0x67, 0xba, 0xb7, 0x6e,
	0x4c, 0x87, 0xb4, 0x21, 0xcd, 0x70, 0x26, 0x25, 0xb0, 0x76, 0x99, 0xa4, 0xba, 0x7e, 0xf5, 0x83,
	0x4d, 0x46, 0xf0, 0x7a, 0xe0, 0x96, 0x75, 0xd1, 0xa6, 0x3a, 0x06, 0x64, 0x25, 0xa3, 0xff, 0xd0,
	0x16, 0x54, 0xb9, 0x58, 0xd7, 0xce, 0xd7, 0x35, 0xf4, 0xda, 0x31, 0x4f, 0x27, 0x58, 0x4a, 0x78,
	0xbb, 0xe0, 0x96, 0x39, 0xb7, 0x7d, 0xa1, 0xf2, 0x7e, 0x0e, 0xf7, 0x0d, 0xdd, 0xb3, 0x51, 0x3f,
	0x25, 0x01, 0x3d, 0xe8, 0xf6, 0x92, 0x01, 0x8d, 0xd1, 0x27, 0xb0, 0xc0, 0xc5, 0x87, 0xf9, 0xce,
	0x90, 0x63, 0x53, 0xf1, 0x44, 0xc4, 0x49, 0xd6, 0xc3, 0x95, 0xed, 0x9c, 0xe0, 0xfd, 0xd3, 0x82,
	0xc7, 0xb3, 0x0b, 0x1c, 0x77, 0x73, 0x28, 0x3c, 0x01, 0x08, 0xd9, 0x41, 0x18, 0x87, 0xec, 0x4a,
	0x77, 0xa4, 0x1a, 0x36, 0x28, 0x62, 0x0f, 0x75, 0xff, 0x3c, 0x18, 0x47, 0x91, 0x2c, 0x52, 0xd5,
	0x3e, 0xca, 0x64, 0x31, 0xe5, 0x99, 0x4f, 0xe2, 0x97, 0xa7, 0xd2, 0x7b, 0x5d, 0x1a, 0x25, 0xa7,
	0x4d, 0x09, 0xf4, 0x8d, 0x52, 0xd0, 0xe1, 0xea, 0xc3, 0xec, 0xe3, 0x52, 0xa6, 0x8b, 0x39, 0xc1,
	0xa6, 0x86, 0xf7, 0x47, 0x0b, 0x9a, 0xb3, 0xa2, 0xb8, 0x27, 0xa2, 0x3b, 0x4d, 0x93, 0x7e, 0x4a,
	0x19, 0x43, 0x9f, 0xc2, 0x4a, 0x3c, 0x1e, 0xee, 0x45, 0xd1, 0xbe, 0x6c, 0x48, 0x4c, 0x77, 0xdd,
	0x22, 0x51, 0x1c, 0xe5, 0xe3, 0xf1, 0x50, 0x5b, 0x08, 0xa6, 0xa2, 0xaa, 0xfd, 0xce, 0xe1, 0xa0,
	0xe7, 0xb0, 0x2c, 0x3c, 0x89, 0x69, 0x3a, 0x8d, 0x76, 0xce, 0x16, 0x15, 0x44, 0xbc, 0x5f, 0xcf,
	0xdd, 0x0b, 0xe5, 0xed, 0xed, 0xf6, 0xe2, 0x50, 0x2d, 0x3a, 0x0d, 0x4d, 0x57, 0xe2, 0xa7, 0xf3,
	0x33, 0x56, 0x4c, 0x03, 0x2e, 0x68, 0xee, 0xaf, 0xed, 0xaf, 0x14, 0x1e, 0xd0, 0xff, 0x17, 0x00,
	0x00, 0xff, 0xff, 0x8c, 0x29, 0x53, 0x17, 0x50, 0x17, 0x00, 0x00,
}
